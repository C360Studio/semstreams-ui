// Code generated by Tester Agent. DO NOT EDIT.
// Task: Phase 0 - Infrastructure Safety for E2E Tests
// Builder must make these tests pass without modification.

import { describe, it, expect, vi, beforeEach, afterEach } from 'vitest';
import { execSync } from 'child_process';
import {
	checkPortAvailability,
	findAvailablePort,
	detectE2EContainers,
	getProjectName,
	getPortFromContainers,
	selectE2EPort
} from './global-setup';

// Mock child_process to avoid actual system calls during tests
vi.mock('child_process', () => ({
	execSync: vi.fn()
}));

/**
 * Test suite for E2E infrastructure safety utilities.
 * These utilities ensure that multiple E2E test runs can coexist
 * without port conflicts or container name collisions.
 */
describe('E2E Infrastructure Safety', () => {
	beforeEach(() => {
		vi.clearAllMocks();
	});

	afterEach(() => {
		vi.restoreAllMocks();
	});

	describe('checkPortAvailability', () => {
		it('should return true when port is available', () => {
			// Mock lsof to return empty output (port not in use)
			vi.mocked(execSync).mockReturnValue(Buffer.from(''));

			const result = checkPortAvailability(3000);

			expect(result).toBe(true);
			expect(execSync).toHaveBeenCalledWith(
				expect.stringContaining('lsof'),
				expect.objectContaining({ encoding: 'utf-8' })
			);
		});

		it('should return false when port is in use', () => {
			// Mock lsof to return process info (port in use)
			vi.mocked(execSync).mockReturnValue(
				Buffer.from('COMMAND   PID USER   FD   TYPE DEVICE SIZE/OFF NODE NAME\nnode    12345 user   18u  IPv6 0x1234      0t0  TCP *:3000 (LISTEN)')
			);

			const result = checkPortAvailability(3000);

			expect(result).toBe(false);
		});

		it('should handle lsof command errors gracefully', () => {
			// Mock lsof to throw error (command not found or permission denied)
			vi.mocked(execSync).mockImplementation(() => {
				throw new Error('lsof: command not found');
			});

			const result = checkPortAvailability(3000);

			// Should return false when lsof fails (conservative approach)
			expect(result).toBe(false);
		});

		it.each([
			{ port: 3000, description: 'default E2E port' },
			{ port: 3010, description: 'mid-range port' },
			{ port: 3019, description: 'max range port' },
			{ port: 1024, description: 'low port number' },
			{ port: 65535, description: 'max valid port' }
		])('should check $description ($port) correctly', ({ port }) => {
			vi.mocked(execSync).mockReturnValue(Buffer.from(''));

			const result = checkPortAvailability(port);

			expect(result).toBe(true);
			expect(execSync).toHaveBeenCalledWith(
				expect.stringContaining(`${port}`),
				expect.any(Object)
			);
		});

		it('should validate port number range', () => {
			// Test invalid port numbers
			const invalidPorts = [0, -1, 65536, 100000, NaN];

			invalidPorts.forEach(port => {
				expect(() => checkPortAvailability(port)).toThrow('Invalid port number');
			});
		});

		it('should handle non-integer port numbers', () => {
			expect(() => checkPortAvailability(3000.5)).toThrow('Port must be an integer');
		});
	});

	describe('findAvailablePort', () => {
		it('should find first available port in range', () => {
			// Mock first port (3000) as unavailable, second port (3001) as available
			vi.mocked(execSync)
				.mockReturnValueOnce(Buffer.from('node    12345 user   18u  IPv6 0x1234      0t0  TCP *:3000 (LISTEN)'))
				.mockReturnValueOnce(Buffer.from(''));

			const port = findAvailablePort(3000, 3019);

			expect(port).toBe(3001);
		});

		it('should return first port if immediately available', () => {
			vi.mocked(execSync).mockReturnValue(Buffer.from(''));

			const port = findAvailablePort(3000, 3019);

			expect(port).toBe(3000);
		});

		it('should throw error when no ports available in range', () => {
			// Mock all ports as occupied
			vi.mocked(execSync).mockReturnValue(
				Buffer.from('node    12345 user   18u  IPv6 0x1234      0t0  TCP *:3000 (LISTEN)')
			);

			expect(() => findAvailablePort(3000, 3002)).toThrow(
				'No available ports in range 3000-3002'
			);
		});

		it('should scan correct number of ports', () => {
			// All ports occupied
			vi.mocked(execSync).mockReturnValue(
				Buffer.from('node    12345 user   18u  IPv6 0x1234      0t0  TCP *:3000 (LISTEN)')
			);

			try {
				findAvailablePort(3000, 3005);
			} catch {
				// Should have checked ports 3000, 3001, 3002, 3003, 3004, 3005 (6 ports)
				expect(execSync).toHaveBeenCalledTimes(6);
			}
		});

		it.each([
			{ start: 3000, end: 3019, description: 'default range' },
			{ start: 3000, end: 3000, description: 'single port range' },
			{ start: 4000, end: 4005, description: 'custom range' }
		])('should handle $description correctly', ({ start, end }) => {
			vi.mocked(execSync).mockReturnValue(Buffer.from(''));

			const port = findAvailablePort(start, end);

			expect(port).toBeGreaterThanOrEqual(start);
			expect(port).toBeLessThanOrEqual(end);
		});

		it('should validate start port is less than or equal to end port', () => {
			expect(() => findAvailablePort(3019, 3000)).toThrow(
				'Start port must be less than or equal to end port'
			);
		});

		it('should validate port range bounds', () => {
			expect(() => findAvailablePort(-1, 3000)).toThrow('Invalid port number');
			expect(() => findAvailablePort(3000, 70000)).toThrow('Invalid port number');
		});

		it('should skip ports with check errors and continue searching', () => {
			// First port throws error, second port is available
			vi.mocked(execSync)
				.mockImplementationOnce(() => {
					throw new Error('lsof failed');
				})
				.mockReturnValueOnce(Buffer.from(''));

			const port = findAvailablePort(3000, 3019);

			// Should skip 3000 (error) and return 3001
			expect(port).toBe(3001);
		});
	});

	describe('detectE2EContainers', () => {
		it('should return empty array when no E2E containers running', () => {
			vi.mocked(execSync).mockReturnValue(Buffer.from(''));

			const containers = detectE2EContainers();

			expect(containers).toEqual([]);
			expect(execSync).toHaveBeenCalledWith(
				expect.stringContaining('docker ps'),
				expect.any(Object)
			);
		});

		it('should detect semstreams-ui-e2e containers', () => {
			const dockerPsOutput = `
CONTAINER ID   IMAGE                  COMMAND                  CREATED        STATUS        PORTS                    NAMES
abc123         semstreams-ui:e2e      "docker-entrypoint.s…"   2 hours ago    Up 2 hours    0.0.0.0:3000->3000/tcp   semstreams-ui-e2e-caddy
def456         semstreams-backend     "/app/semstreams"        2 hours ago    Up 2 hours                             semstreams-ui-e2e-backend
ghi789         nats:2.10-alpine       "nats-server -js -s…"    2 hours ago    Up 2 hours    4222/tcp                 semstreams-ui-e2e-nats
			`.trim();

			vi.mocked(execSync).mockReturnValue(Buffer.from(dockerPsOutput));

			const containers = detectE2EContainers();

			expect(containers).toHaveLength(3);
			expect(containers).toContain('semstreams-ui-e2e-caddy');
			expect(containers).toContain('semstreams-ui-e2e-backend');
			expect(containers).toContain('semstreams-ui-e2e-nats');
		});

		it('should only return containers matching e2e pattern', () => {
			const dockerPsOutput = `
CONTAINER ID   IMAGE                  COMMAND                  CREATED        STATUS        PORTS                    NAMES
abc123         semstreams-ui:e2e      "docker-entrypoint.s…"   2 hours ago    Up 2 hours    0.0.0.0:3000->3000/tcp   semstreams-ui-e2e-caddy
def456         postgres:15            "docker-entrypoint.s…"   1 day ago      Up 1 day      5432/tcp                 my-database
ghi789         redis:7                "docker-entrypoint.s…"   1 day ago      Up 1 day      6379/tcp                 my-redis
jkl012         nats:2.10-alpine       "nats-server -js -s…"    2 hours ago    Up 2 hours    4222/tcp                 semstreams-ui-e2e-nats
			`.trim();

			vi.mocked(execSync).mockReturnValue(Buffer.from(dockerPsOutput));

			const containers = detectE2EContainers();

			// Should only include semstreams-ui-e2e-* containers
			expect(containers).toHaveLength(2);
			expect(containers).toContain('semstreams-ui-e2e-caddy');
			expect(containers).toContain('semstreams-ui-e2e-nats');
			expect(containers).not.toContain('my-database');
			expect(containers).not.toContain('my-redis');
		});

		it('should handle docker command errors gracefully', () => {
			vi.mocked(execSync).mockImplementation(() => {
				throw new Error('Docker daemon not running');
			});

			const containers = detectE2EContainers();

			// Should return empty array on error
			expect(containers).toEqual([]);
		});

		it('should filter by project name pattern when provided', () => {
			const dockerPsOutput = `
CONTAINER ID   IMAGE                  COMMAND                  CREATED        STATUS        PORTS                    NAMES
abc123         semstreams-ui:e2e      "docker-entrypoint.s…"   2 hours ago    Up 2 hours    0.0.0.0:3000->3000/tcp   semstreams-ui-e2e-project1-caddy
def456         semstreams-ui:e2e      "docker-entrypoint.s…"   2 hours ago    Up 2 hours    0.0.0.0:3001->3000/tcp   semstreams-ui-e2e-project2-caddy
ghi789         nats:2.10-alpine       "nats-server -js -s…"    2 hours ago    Up 2 hours    4222/tcp                 semstreams-ui-e2e-project1-nats
			`.trim();

			vi.mocked(execSync).mockReturnValue(Buffer.from(dockerPsOutput));

			const containers = detectE2EContainers('project1');

			// Should only return containers for project1
			expect(containers).toHaveLength(2);
			expect(containers).toContain('semstreams-ui-e2e-project1-caddy');
			expect(containers).toContain('semstreams-ui-e2e-project1-nats');
			expect(containers).not.toContain('semstreams-ui-e2e-project2-caddy');
		});

		it('should handle malformed docker ps output', () => {
			const malformedOutput = `
CONTAINER ID   IMAGE
abc123         semstreams
			`.trim();

			vi.mocked(execSync).mockReturnValue(Buffer.from(malformedOutput));

			// Should not crash on malformed output
			const containers = detectE2EContainers();
			expect(Array.isArray(containers)).toBe(true);
		});
	});

	describe('getProjectName', () => {
		it('should generate unique project name', () => {
			const name1 = getProjectName();
			const name2 = getProjectName();

			expect(name1).toMatch(/^e2e-\d+-[a-z0-9]+$/);
			expect(name2).toMatch(/^e2e-\d+-[a-z0-9]+$/);
			expect(name1).not.toBe(name2);
		});

		it('should include timestamp component', () => {
			const beforeTimestamp = Date.now();
			const projectName = getProjectName();
			const afterTimestamp = Date.now();

			// Extract timestamp from project name (format: e2e-TIMESTAMP-RANDOM)
			const match = projectName.match(/^e2e-(\d+)-[a-z0-9]+$/);
			expect(match).not.toBeNull();

			const timestamp = parseInt(match![1]);
			expect(timestamp).toBeGreaterThanOrEqual(beforeTimestamp);
			expect(timestamp).toBeLessThanOrEqual(afterTimestamp);
		});

		it('should include random component for uniqueness', () => {
			const name1 = getProjectName();
			const name2 = getProjectName();

			// Extract random suffixes
			const suffix1 = name1.split('-')[2];
			const suffix2 = name2.split('-')[2];

			expect(suffix1).toMatch(/^[a-z0-9]+$/);
			expect(suffix2).toMatch(/^[a-z0-9]+$/);
			// Different calls should produce different random suffixes (highly likely)
			expect(suffix1).not.toBe(suffix2);
		});

		it('should generate project name without special characters', () => {
			const projectName = getProjectName();

			// Should only contain lowercase letters, digits, and hyphens
			expect(projectName).toMatch(/^[a-z0-9-]+$/);
		});

		it('should allow custom prefix', () => {
			const projectName = getProjectName('test');

			expect(projectName).toMatch(/^test-\d+-[a-z0-9]+$/);
		});

		it('should handle empty prefix gracefully', () => {
			const projectName = getProjectName('');

			// Should use default prefix 'e2e' when empty string provided
			expect(projectName).toMatch(/^e2e-\d+-[a-z0-9]+$/);
		});

		it('should sanitize prefix with special characters', () => {
			const projectName = getProjectName('my_test@project#123');

			// Should remove or replace special characters
			expect(projectName).toMatch(/^[a-z0-9-]+$/);
		});

		it.each([
			{ prefix: 'e2e', description: 'default prefix' },
			{ prefix: 'test', description: 'custom prefix' },
			{ prefix: 'ci', description: 'short prefix' },
			{ prefix: 'integration', description: 'long prefix' }
		])('should generate valid name with $description', ({ prefix }) => {
			const projectName = getProjectName(prefix);

			expect(projectName).toMatch(/^[a-z0-9-]+$/);
			expect(projectName.startsWith(prefix)).toBe(true);
		});
	});

	describe('getPortFromContainers', () => {
		it('should extract port from caddy container port mapping', () => {
			const containers = [
				'semstreams-ui-e2e-caddy'
			];

			// Mock docker inspect to return port mapping
			vi.mocked(execSync).mockReturnValue(
				Buffer.from(JSON.stringify([{ NetworkSettings: { Ports: { '3000/tcp': [{ HostPort: '3005' }] } } }]))
			);

			const port = getPortFromContainers(containers);

			expect(port).toBe(3005);
		});

		it('should return null when no caddy container found', () => {
			const containers = [
				'semstreams-ui-e2e-backend',
				'semstreams-ui-e2e-nats'
			];

			const port = getPortFromContainers(containers);

			expect(port).toBeNull();
		});

		it('should handle docker inspect errors', () => {
			const containers = [
				'semstreams-ui-e2e-caddy'
			];

			vi.mocked(execSync).mockImplementation(() => {
				throw new Error('Container not found');
			});

			const port = getPortFromContainers(containers);

			// Should return null on error
			expect(port).toBeNull();
		});

		it('should handle containers without port mappings', () => {
			const containers = [
				'semstreams-ui-e2e-caddy'
			];

			vi.mocked(execSync).mockReturnValue(
				Buffer.from(JSON.stringify([{ NetworkSettings: { Ports: {} } }]))
			);

			const port = getPortFromContainers(containers);

			expect(port).toBeNull();
		});
	});

	describe('selectE2EPort', () => {
		it('should use E2E_UI_PORT environment variable when set and available', () => {
			process.env.E2E_UI_PORT = '3010';
			vi.mocked(execSync).mockReturnValue(Buffer.from('')); // Port available

			const port = selectE2EPort();

			expect(port).toBe(3010);
			delete process.env.E2E_UI_PORT;
		});

		it('should find next available port when E2E_UI_PORT is occupied', () => {
			process.env.E2E_UI_PORT = '3000';

			// Mock port 3000 as occupied, 3001 as available
			vi.mocked(execSync)
				.mockReturnValueOnce(Buffer.from('node    12345 user   18u  IPv6 0x1234      0t0  TCP *:3000 (LISTEN)'))
				.mockReturnValueOnce(Buffer.from(''));

			const port = selectE2EPort();

			expect(port).toBe(3001);
			delete process.env.E2E_UI_PORT;
		});

		it('should detect existing E2E containers and reuse port', () => {
			const dockerPsOutput = `
CONTAINER ID   IMAGE                  COMMAND                  CREATED        STATUS        PORTS                    NAMES
abc123         semstreams-ui:e2e      "docker-entrypoint.s…"   2 hours ago    Up 2 hours    0.0.0.0:3005->3000/tcp   semstreams-ui-e2e-caddy
			`.trim();

			vi.mocked(execSync)
				.mockReturnValueOnce(Buffer.from(dockerPsOutput)) // docker ps
				.mockReturnValueOnce(
					Buffer.from(JSON.stringify([{ NetworkSettings: { Ports: { '3000/tcp': [{ HostPort: '3005' }] } } }]))
				); // docker inspect

			const port = selectE2EPort();

			// Should reuse existing container's port
			expect(port).toBe(3005);
		});

		it('should use default port 3000 when available and no env var set', () => {
			delete process.env.E2E_UI_PORT;

			vi.mocked(execSync)
				.mockReturnValueOnce(Buffer.from('')) // docker ps (no containers)
				.mockReturnValueOnce(Buffer.from('')); // lsof (port available)

			const port = selectE2EPort();

			expect(port).toBe(3000);
		});

		it('should find next available port when default is occupied and no containers exist', () => {
			delete process.env.E2E_UI_PORT;

			vi.mocked(execSync)
				.mockReturnValueOnce(Buffer.from('')) // docker ps (no containers)
				.mockReturnValueOnce(
					Buffer.from('node    12345 user   18u  IPv6 0x1234      0t0  TCP *:3000 (LISTEN)')
				) // port 3000 occupied
				.mockReturnValueOnce(Buffer.from('')); // port 3001 available

			const port = selectE2EPort();

			expect(port).toBe(3001);
		});

		it('should throw error when no ports available in range', () => {
			delete process.env.E2E_UI_PORT;

			// Mock all checks to show ports occupied
			vi.mocked(execSync).mockReturnValue(
				Buffer.from('node    12345 user   18u  IPv6 0x1234      0t0  TCP *:3000 (LISTEN)')
			);

			expect(() => selectE2EPort()).toThrow('No available ports in range 3000-3019');
		});
	});

	describe('Integration: Port Selection Workflow', () => {
		it('should handle complete workflow: detect containers -> extract port -> reuse', () => {
			const dockerPsOutput = `
CONTAINER ID   IMAGE                  COMMAND                  CREATED        STATUS        PORTS                    NAMES
abc123         semstreams-ui:e2e      "docker-entrypoint.s…"   2 hours ago    Up 2 hours    0.0.0.0:3008->3000/tcp   semstreams-ui-e2e-caddy
def456         semstreams-backend     "/app/semstreams"        2 hours ago    Up 2 hours                             semstreams-ui-e2e-backend
			`.trim();

			vi.mocked(execSync)
				.mockReturnValueOnce(Buffer.from(dockerPsOutput)) // docker ps
				.mockReturnValueOnce(
					Buffer.from(JSON.stringify([{ NetworkSettings: { Ports: { '3000/tcp': [{ HostPort: '3008' }] } } }]))
				); // docker inspect

			const containers = detectE2EContainers();
			expect(containers).toHaveLength(2);

			const port = getPortFromContainers(containers);
			expect(port).toBe(3008);
		});

		it('should handle complete workflow: no containers -> check availability -> assign port', () => {
			vi.mocked(execSync)
				.mockReturnValueOnce(Buffer.from('')) // docker ps (no containers)
				.mockReturnValueOnce(Buffer.from('')) // port check (available)
				.mockReturnValueOnce(Buffer.from('')); // additional availability check

			const containers = detectE2EContainers();
			expect(containers).toEqual([]);

			const port = findAvailablePort(3000, 3019);
			expect(port).toBe(3000);
		});

		it('should handle race condition: port becomes unavailable between check and use', () => {
			// First check shows port available
			// Second check shows port occupied (race condition)
			vi.mocked(execSync)
				.mockReturnValueOnce(Buffer.from('')) // first check: available
				.mockReturnValueOnce(
					Buffer.from('node    12345 user   18u  IPv6 0x1234      0t0  TCP *:3000 (LISTEN)')
				) // second check: occupied
				.mockReturnValueOnce(Buffer.from('')); // third check: next port available

			const firstCheck = checkPortAvailability(3000);
			expect(firstCheck).toBe(true);

			// Simulate race: another process took the port
			const secondCheck = checkPortAvailability(3000);
			expect(secondCheck).toBe(false);

			// Find next available
			const port = findAvailablePort(3001, 3019);
			expect(port).toBe(3001);
		});
	});
});
