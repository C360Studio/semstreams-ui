// Code generated by Tester Agent. DO NOT EDIT.
// Task: Phase 1 - Backend Helpers Tests
// Builder must make these tests pass without modification.

import { describe, it, expect, beforeEach, vi } from 'vitest';
import type { Page } from '@playwright/test';

// Import types from existing helpers for consistency
import type { FlowResponse } from './flow-setup';

// Types for backend helpers
interface FlowSummary {
	id: string;
	name: string;
	description?: string;
	runtime_state: string;
	created_at: string;
	updated_at: string;
}

interface ComponentType {
	id: string;
	name: string;
	type: string;
	protocol: string;
	category: string;
	description: string;
	schema: Record<string, unknown>;
}

interface _HealthResponse {
	status: string;
	version?: string;
}

// Mock backend-helpers module for testing
// Builder will implement actual backend-helpers.ts
describe('backend-helpers', () => {
	let mockPage: Page;
	let mockRequest: ReturnType<typeof vi.fn>;

	beforeEach(() => {
		mockRequest = vi.fn();
		mockPage = {
			request: {
				get: mockRequest,
				post: mockRequest,
				delete: mockRequest
			}
		} as unknown as Page;
	});

	describe('verifyBackendHealth', () => {
		it('should return true when backend is healthy', async () => {
			const mockResponse = {
				ok: () => true,
				status: () => 200,
				json: async () => ({ status: 'ok', version: '1.0.0' })
			};
			mockRequest.mockResolvedValueOnce(mockResponse);

			// Test the behavior expected from verifyBackendHealth
			const { verifyBackendHealth } = await import('./backend-helpers');
			const result = await verifyBackendHealth(mockPage);

			expect(result).toBe(true);
			expect(mockRequest).toHaveBeenCalledWith('/health');
		});

		it('should return false when backend returns non-200 status', async () => {
			const mockResponse = {
				ok: () => false,
				status: () => 500,
				json: async () => ({})
			};
			mockRequest.mockResolvedValueOnce(mockResponse);

			const { verifyBackendHealth } = await import('./backend-helpers');
			const result = await verifyBackendHealth(mockPage);

			expect(result).toBe(false);
		});

		it('should return false when backend request fails', async () => {
			mockRequest.mockRejectedValueOnce(new Error('Network error'));

			const { verifyBackendHealth } = await import('./backend-helpers');
			const result = await verifyBackendHealth(mockPage);

			expect(result).toBe(false);
		});

		it('should return false when backend is unreachable (timeout)', async () => {
			mockRequest.mockImplementationOnce(
				() =>
					new Promise((_, reject) =>
						setTimeout(() => reject(new Error('Timeout')), 100)
					)
			);

			const { verifyBackendHealth } = await import('./backend-helpers');
			const result = await verifyBackendHealth(mockPage);

			expect(result).toBe(false);
		});
	});

	describe('listFlows', () => {
		it('should return array of flows from backend', async () => {
			const mockFlows: FlowSummary[] = [
				{
					id: 'flow-1',
					name: 'Test Flow 1',
					description: 'First test flow',
					runtime_state: 'not_deployed',
					created_at: '2025-01-01T00:00:00Z',
					updated_at: '2025-01-01T00:00:00Z'
				},
				{
					id: 'flow-2',
					name: 'Test Flow 2',
					runtime_state: 'running',
					created_at: '2025-01-02T00:00:00Z',
					updated_at: '2025-01-02T00:00:00Z'
				}
			];

			const mockResponse = {
				ok: () => true,
				status: () => 200,
				json: async () => ({ flows: mockFlows })
			};
			mockRequest.mockResolvedValueOnce(mockResponse);

			const { listFlows } = await import('./backend-helpers');
			const result = await listFlows(mockPage);

			expect(result).toEqual(mockFlows);
			expect(mockRequest).toHaveBeenCalledWith('/flowbuilder/flows');
		});

		it('should return empty array when no flows exist', async () => {
			const mockResponse = {
				ok: () => true,
				status: () => 200,
				json: async () => ({ flows: [] })
			};
			mockRequest.mockResolvedValueOnce(mockResponse);

			const { listFlows } = await import('./backend-helpers');
			const result = await listFlows(mockPage);

			expect(result).toEqual([]);
		});

		it('should throw error when request fails', async () => {
			const mockResponse = {
				ok: () => false,
				status: () => 500,
				statusText: () => 'Internal Server Error',
				text: async () => 'Database connection failed'
			};
			mockRequest.mockResolvedValueOnce(mockResponse);

			const { listFlows } = await import('./backend-helpers');

			await expect(listFlows(mockPage)).rejects.toThrow();
		});

		it('should throw error when response is malformed', async () => {
			const mockResponse = {
				ok: () => true,
				status: () => 200,
				json: async () => {
					throw new Error('Invalid JSON');
				}
			};
			mockRequest.mockResolvedValueOnce(mockResponse);

			const { listFlows } = await import('./backend-helpers');

			await expect(listFlows(mockPage)).rejects.toThrow();
		});
	});

	describe('getFlow', () => {
		it('should return specific flow by ID', async () => {
			const mockFlow: FlowResponse = {
				id: 'flow-123',
				name: 'Test Flow',
				description: 'A test flow',
				version: 1,
				runtime_state: 'not_deployed',
				nodes: [
					{
						id: 'node-1',
						type: 'udp-input',
						name: 'udp 1',
						config: { port: 5000 }
					}
				],
				connections: [],
				created_at: '2025-01-01T00:00:00Z',
				updated_at: '2025-01-01T00:00:00Z',
				last_modified: '2025-01-01T00:00:00Z'
			};

			const mockResponse = {
				ok: () => true,
				status: () => 200,
				json: async () => mockFlow
			};
			mockRequest.mockResolvedValueOnce(mockResponse);

			const { getFlow } = await import('./backend-helpers');
			const result = await getFlow(mockPage, 'flow-123');

			expect(result).toEqual(mockFlow);
			expect(mockRequest).toHaveBeenCalledWith('/flowbuilder/flows/flow-123');
		});

		it('should throw error when flow not found (404)', async () => {
			const mockResponse = {
				ok: () => false,
				status: () => 404,
				statusText: () => 'Not Found',
				text: async () => 'Flow not found'
			};
			mockRequest.mockResolvedValueOnce(mockResponse);

			const { getFlow } = await import('./backend-helpers');

			await expect(getFlow(mockPage, 'nonexistent')).rejects.toThrow();
		});

		it('should throw error when flowId is empty string', async () => {
			const { getFlow } = await import('./backend-helpers');

			await expect(getFlow(mockPage, '')).rejects.toThrow();
		});

		it('should handle special characters in flowId', async () => {
			const mockFlow: FlowResponse = {
				id: 'flow-with-special-chars-!@#',
				name: 'Special Flow',
				version: 1,
				runtime_state: 'not_deployed',
				nodes: [],
				connections: [],
				created_at: '2025-01-01T00:00:00Z',
				updated_at: '2025-01-01T00:00:00Z',
				last_modified: '2025-01-01T00:00:00Z'
			};

			const mockResponse = {
				ok: () => true,
				status: () => 200,
				json: async () => mockFlow
			};
			mockRequest.mockResolvedValueOnce(mockResponse);

			const { getFlow } = await import('./backend-helpers');
			const result = await getFlow(mockPage, 'flow-with-special-chars-!@#');

			expect(result).toEqual(mockFlow);
		});
	});

	describe('cleanupAllTestFlows', () => {
		it('should delete all flows matching "E2E Test" pattern', async () => {
			const mockFlows: FlowSummary[] = [
				{
					id: 'flow-1',
					name: 'E2E Test Flow 1',
					runtime_state: 'not_deployed',
					created_at: '2025-01-01T00:00:00Z',
					updated_at: '2025-01-01T00:00:00Z'
				},
				{
					id: 'flow-2',
					name: 'E2E Test Flow 2',
					runtime_state: 'not_deployed',
					created_at: '2025-01-02T00:00:00Z',
					updated_at: '2025-01-02T00:00:00Z'
				},
				{
					id: 'flow-3',
					name: 'Production Flow',
					runtime_state: 'running',
					created_at: '2025-01-03T00:00:00Z',
					updated_at: '2025-01-03T00:00:00Z'
				}
			];

			const listResponse = {
				ok: () => true,
				status: () => 200,
				json: async () => ({ flows: mockFlows })
			};

			const deleteResponse = {
				ok: () => true,
				status: () => 204
			};

			mockRequest.mockResolvedValueOnce(listResponse);
			mockRequest.mockResolvedValueOnce(deleteResponse); // flow-1
			mockRequest.mockResolvedValueOnce(deleteResponse); // flow-2

			const { cleanupAllTestFlows } = await import('./backend-helpers');
			await cleanupAllTestFlows(mockPage);

			// Should have called GET /flows once, DELETE twice (only E2E Test flows)
			expect(mockRequest).toHaveBeenCalledTimes(3);
			expect(mockRequest).toHaveBeenNthCalledWith(1, '/flowbuilder/flows');
			expect(mockRequest).toHaveBeenNthCalledWith(2, '/flowbuilder/flows/flow-1', {
				method: 'DELETE'
			});
			expect(mockRequest).toHaveBeenNthCalledWith(3, '/flowbuilder/flows/flow-2', {
				method: 'DELETE'
			});
		});

		it('should not delete flows without "E2E Test" in name', async () => {
			const mockFlows: FlowSummary[] = [
				{
					id: 'flow-1',
					name: 'Production Flow',
					runtime_state: 'running',
					created_at: '2025-01-01T00:00:00Z',
					updated_at: '2025-01-01T00:00:00Z'
				},
				{
					id: 'flow-2',
					name: 'User Flow',
					runtime_state: 'not_deployed',
					created_at: '2025-01-02T00:00:00Z',
					updated_at: '2025-01-02T00:00:00Z'
				}
			];

			const listResponse = {
				ok: () => true,
				status: () => 200,
				json: async () => ({ flows: mockFlows })
			};

			mockRequest.mockResolvedValueOnce(listResponse);

			const { cleanupAllTestFlows } = await import('./backend-helpers');
			await cleanupAllTestFlows(mockPage);

			// Should only have called GET, no DELETE calls
			expect(mockRequest).toHaveBeenCalledTimes(1);
			expect(mockRequest).toHaveBeenCalledWith('/flowbuilder/flows');
		});

		it('should handle empty flow list gracefully', async () => {
			const listResponse = {
				ok: () => true,
				status: () => 200,
				json: async () => ({ flows: [] })
			};

			mockRequest.mockResolvedValueOnce(listResponse);

			const { cleanupAllTestFlows } = await import('./backend-helpers');
			await cleanupAllTestFlows(mockPage);

			expect(mockRequest).toHaveBeenCalledTimes(1);
		});

		it('should continue cleanup even if some deletes fail', async () => {
			const mockFlows: FlowSummary[] = [
				{
					id: 'flow-1',
					name: 'E2E Test Flow 1',
					runtime_state: 'not_deployed',
					created_at: '2025-01-01T00:00:00Z',
					updated_at: '2025-01-01T00:00:00Z'
				},
				{
					id: 'flow-2',
					name: 'E2E Test Flow 2',
					runtime_state: 'not_deployed',
					created_at: '2025-01-02T00:00:00Z',
					updated_at: '2025-01-02T00:00:00Z'
				}
			];

			const listResponse = {
				ok: () => true,
				status: () => 200,
				json: async () => ({ flows: mockFlows })
			};

			const successResponse = {
				ok: () => true,
				status: () => 204
			};

			const failResponse = {
				ok: () => false,
				status: () => 500,
				statusText: () => 'Internal Server Error'
			};

			mockRequest.mockResolvedValueOnce(listResponse);
			mockRequest.mockResolvedValueOnce(failResponse); // flow-1 fails
			mockRequest.mockResolvedValueOnce(successResponse); // flow-2 succeeds

			const { cleanupAllTestFlows } = await import('./backend-helpers');

			// Should not throw, should attempt all deletions
			await expect(cleanupAllTestFlows(mockPage)).resolves.not.toThrow();

			expect(mockRequest).toHaveBeenCalledTimes(3);
		});

		it('should handle 404 on delete (already deleted)', async () => {
			const mockFlows: FlowSummary[] = [
				{
					id: 'flow-1',
					name: 'E2E Test Flow 1',
					runtime_state: 'not_deployed',
					created_at: '2025-01-01T00:00:00Z',
					updated_at: '2025-01-01T00:00:00Z'
				}
			];

			const listResponse = {
				ok: () => true,
				status: () => 200,
				json: async () => ({ flows: mockFlows })
			};

			const notFoundResponse = {
				ok: () => false,
				status: () => 404,
				statusText: () => 'Not Found'
			};

			mockRequest.mockResolvedValueOnce(listResponse);
			mockRequest.mockResolvedValueOnce(notFoundResponse);

			const { cleanupAllTestFlows } = await import('./backend-helpers');

			// 404 should be treated as success (already deleted)
			await expect(cleanupAllTestFlows(mockPage)).resolves.not.toThrow();
		});
	});

	describe('getComponentTypes', () => {
		it('should return array of component types', async () => {
			const mockComponents: ComponentType[] = [
				{
					id: 'udp-input',
					name: 'UDP Input',
					type: 'input',
					protocol: 'udp',
					category: 'input',
					description: 'UDP network input',
					schema: {
						type: 'object',
						properties: {
							port: { type: 'number' }
						}
					}
				},
				{
					id: 'tcp-output',
					name: 'TCP Output',
					type: 'output',
					protocol: 'tcp',
					category: 'output',
					description: 'TCP network output',
					schema: {
						type: 'object',
						properties: {
							host: { type: 'string' },
							port: { type: 'number' }
						}
					}
				}
			];

			const mockResponse = {
				ok: () => true,
				status: () => 200,
				json: async () => mockComponents
			};
			mockRequest.mockResolvedValueOnce(mockResponse);

			const { getComponentTypes } = await import('./backend-helpers');
			const result = await getComponentTypes(mockPage);

			expect(result).toEqual(mockComponents);
			expect(mockRequest).toHaveBeenCalledWith('/components/types');
		});

		it('should return empty array when no components exist', async () => {
			const mockResponse = {
				ok: () => true,
				status: () => 200,
				json: async () => []
			};
			mockRequest.mockResolvedValueOnce(mockResponse);

			const { getComponentTypes } = await import('./backend-helpers');
			const result = await getComponentTypes(mockPage);

			expect(result).toEqual([]);
		});

		it('should throw error when request fails', async () => {
			const mockResponse = {
				ok: () => false,
				status: () => 500,
				statusText: () => 'Internal Server Error',
				text: async () => 'Component registry unavailable'
			};
			mockRequest.mockResolvedValueOnce(mockResponse);

			const { getComponentTypes } = await import('./backend-helpers');

			await expect(getComponentTypes(mockPage)).rejects.toThrow();
		});
	});

	describe('waitForFlowState', () => {
		it('should return immediately when flow is in expected state', async () => {
			const mockFlow: FlowResponse = {
				id: 'flow-123',
				name: 'Test Flow',
				version: 1,
				runtime_state: 'running',
				nodes: [],
				connections: [],
				created_at: '2025-01-01T00:00:00Z',
				updated_at: '2025-01-01T00:00:00Z',
				last_modified: '2025-01-01T00:00:00Z'
			};

			const mockResponse = {
				ok: () => true,
				status: () => 200,
				json: async () => mockFlow
			};
			mockRequest.mockResolvedValueOnce(mockResponse);

			const { waitForFlowState } = await import('./backend-helpers');

			const start = Date.now();
			await waitForFlowState(mockPage, 'flow-123', 'running', 5000);
			const elapsed = Date.now() - start;

			// Should return quickly (less than 1 second)
			expect(elapsed).toBeLessThan(1000);
			expect(mockRequest).toHaveBeenCalledWith('/flowbuilder/flows/flow-123');
		});

		it('should poll until flow reaches expected state', async () => {
			const deployingFlow: FlowResponse = {
				id: 'flow-123',
				name: 'Test Flow',
				version: 1,
				runtime_state: 'deploying',
				nodes: [],
				connections: [],
				created_at: '2025-01-01T00:00:00Z',
				updated_at: '2025-01-01T00:00:00Z',
				last_modified: '2025-01-01T00:00:00Z'
			};

			const runningFlow: FlowResponse = {
				...deployingFlow,
				runtime_state: 'running'
			};

			const deployingResponse = {
				ok: () => true,
				status: () => 200,
				json: async () => deployingFlow
			};

			const runningResponse = {
				ok: () => true,
				status: () => 200,
				json: async () => runningFlow
			};

			mockRequest
				.mockResolvedValueOnce(deployingResponse) // First poll: deploying
				.mockResolvedValueOnce(deployingResponse) // Second poll: still deploying
				.mockResolvedValueOnce(runningResponse); // Third poll: running

			const { waitForFlowState } = await import('./backend-helpers');

			await waitForFlowState(mockPage, 'flow-123', 'running', 5000);

			// Should have polled 3 times
			expect(mockRequest).toHaveBeenCalledTimes(3);
		});

		it('should timeout if state not reached within timeout period', async () => {
			const deployingFlow: FlowResponse = {
				id: 'flow-123',
				name: 'Test Flow',
				version: 1,
				runtime_state: 'deploying',
				nodes: [],
				connections: [],
				created_at: '2025-01-01T00:00:00Z',
				updated_at: '2025-01-01T00:00:00Z',
				last_modified: '2025-01-01T00:00:00Z'
			};

			const mockResponse = {
				ok: () => true,
				status: () => 200,
				json: async () => deployingFlow
			};

			mockRequest.mockResolvedValue(mockResponse); // Always return deploying

			const { waitForFlowState } = await import('./backend-helpers');

			// Use short timeout for faster test
			await expect(
				waitForFlowState(mockPage, 'flow-123', 'running', 500)
			).rejects.toThrow(/timeout/i);
		});

		it('should throw error if flow not found during wait', async () => {
			const notFoundResponse = {
				ok: () => false,
				status: () => 404,
				statusText: () => 'Not Found',
				text: async () => 'Flow not found'
			};

			mockRequest.mockResolvedValueOnce(notFoundResponse);

			const { waitForFlowState } = await import('./backend-helpers');

			await expect(
				waitForFlowState(mockPage, 'nonexistent', 'running', 5000)
			).rejects.toThrow();
		});

		it('should handle multiple valid end states', async () => {
			const stoppedFlow: FlowResponse = {
				id: 'flow-123',
				name: 'Test Flow',
				version: 1,
				runtime_state: 'stopped',
				nodes: [],
				connections: [],
				created_at: '2025-01-01T00:00:00Z',
				updated_at: '2025-01-01T00:00:00Z',
				last_modified: '2025-01-01T00:00:00Z'
			};

			const mockResponse = {
				ok: () => true,
				status: () => 200,
				json: async () => stoppedFlow
			};
			mockRequest.mockResolvedValueOnce(mockResponse);

			const { waitForFlowState } = await import('./backend-helpers');

			// Should accept "stopped" as valid terminal state
			await expect(
				waitForFlowState(mockPage, 'flow-123', 'stopped', 5000)
			).resolves.not.toThrow();
		});

		it('should use default timeout if not specified', async () => {
			const runningFlow: FlowResponse = {
				id: 'flow-123',
				name: 'Test Flow',
				version: 1,
				runtime_state: 'running',
				nodes: [],
				connections: [],
				created_at: '2025-01-01T00:00:00Z',
				updated_at: '2025-01-01T00:00:00Z',
				last_modified: '2025-01-01T00:00:00Z'
			};

			const mockResponse = {
				ok: () => true,
				status: () => 200,
				json: async () => runningFlow
			};
			mockRequest.mockResolvedValueOnce(mockResponse);

			const { waitForFlowState } = await import('./backend-helpers');

			// Should use default timeout (typically 30000ms or similar)
			await expect(
				waitForFlowState(mockPage, 'flow-123', 'running')
			).resolves.not.toThrow();
		});
	});
});
