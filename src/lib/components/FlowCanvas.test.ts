// Code generated by Tester Agent. DO NOT EDIT.
// Task: Sprint 1 - D3 Canvas component tests (FlowCanvas.svelte)
// Builder must make these tests pass without modification.

import { describe, test, expect, vi, beforeEach } from "vitest";
import { render, screen, fireEvent } from "@testing-library/svelte";
import FlowCanvas from "./FlowCanvas.svelte";
import type { FlowNode, FlowConnection } from "$lib/types/flow";

// Mock D3 zoom behavior
vi.mock("d3", async () => {
  const actual = await vi.importActual("d3");
  return {
    ...actual,
    zoom: vi.fn(() => ({
      scaleExtent: vi.fn().mockReturnThis(),
      on: vi.fn().mockReturnThis(),
      transform: vi.fn().mockReturnThis(),
    })),
    select: vi.fn(() => ({
      call: vi.fn().mockReturnThis(),
      transition: vi.fn().mockReturnThis(),
    })),
  };
});

describe("FlowCanvas", () => {
  const mockNodes: FlowNode[] = [
    {
      id: "node-1",
      component: "udp-input",
      type: "input",
      name: "UDP Input",
      position: { x: 0, y: 0 },
      config: { port: 5000 },
    },
    {
      id: "node-2",
      component: "json-transform",
      type: "processor",
      name: "JSON Transform",
      position: { x: 0, y: 0 },
      config: {},
    },
  ];

  const mockConnections: FlowConnection[] = [
    {
      id: "conn-1",
      source_node_id: "node-1",
      source_port: "data_out",
      target_node_id: "node-2",
      target_port: "data_in",
    },
  ];

  const mockPortsMap = {
    "node-1": {
      input_ports: [],
      output_ports: [
        {
          name: "data_out",
          direction: "output" as const,
          type: "message.Storable",
          required: true,
          connection_id: "udp.5000",
          pattern: "stream",
          description: "UDP data output",
        },
      ],
    },
    "node-2": {
      input_ports: [
        {
          name: "data_in",
          direction: "input" as const,
          type: "message.Storable",
          required: true,
          connection_id: "nats.data",
          pattern: "stream",
          description: "Data input",
        },
      ],
      output_ports: [],
    },
  };

  beforeEach(() => {
    vi.clearAllMocks();
  });

  describe("basic rendering", () => {
    test("renders SVG container", () => {
      const { container } = render(FlowCanvas, {
        props: {
          nodes: mockNodes,
          connections: mockConnections,
        },
      });

      const svg = container.querySelector(".flow-canvas");
      expect(svg).toBeInTheDocument();
      expect(svg?.tagName).toBe("svg");
    });

    test("SVG has correct role and aria-label", () => {
      const { container } = render(FlowCanvas, {
        props: {
          nodes: mockNodes,
          connections: mockConnections,
        },
      });

      const svg = container.querySelector(".flow-canvas");
      expect(svg?.getAttribute("role")).toBe("img");
      expect(svg?.getAttribute("aria-label")).toBe("Flow diagram");
    });

    test("renders canvas container div", () => {
      const { container } = render(FlowCanvas, {
        props: {
          nodes: mockNodes,
          connections: mockConnections,
        },
      });

      const containerDiv = container.querySelector(".flow-canvas-container");
      expect(containerDiv).toBeInTheDocument();
    });
  });

  describe("empty state", () => {
    test("shows empty state when no nodes", () => {
      render(FlowCanvas, {
        props: {
          nodes: [],
          connections: [],
        },
      });

      expect(
        screen.getByText("No components in this flow."),
      ).toBeInTheDocument();
    });

    test("empty state shows helpful hint", () => {
      render(FlowCanvas, {
        props: {
          nodes: [],
          connections: [],
        },
      });

      expect(
        screen.getByText(
          /Add components using the sidebar or describe your flow to the AI/i,
        ),
      ).toBeInTheDocument();
    });

    test("hides empty state when nodes exist", () => {
      render(FlowCanvas, {
        props: {
          nodes: mockNodes,
          connections: mockConnections,
        },
      });

      expect(
        screen.queryByText("No components in this flow."),
      ).not.toBeInTheDocument();
    });
  });

  describe("node rendering", () => {
    test("renders nodes from flow data", () => {
      const { container } = render(FlowCanvas, {
        props: {
          nodes: mockNodes,
          connections: mockConnections,
          portsMap: mockPortsMap,
        },
      });

      // Check for FlowNode components by looking for node-label elements
      const nodeLabels = container.querySelectorAll(".node-label");
      expect(nodeLabels.length).toBeGreaterThan(0);
    });

    test("renders correct number of nodes", () => {
      const { container } = render(FlowCanvas, {
        props: {
          nodes: mockNodes,
          connections: mockConnections,
          portsMap: mockPortsMap,
        },
      });

      const flowNodes = container.querySelectorAll(".flow-node");
      expect(flowNodes).toHaveLength(2);
    });

    test("nodes have unique keys", () => {
      const { container } = render(FlowCanvas, {
        props: {
          nodes: mockNodes,
          connections: mockConnections,
          portsMap: mockPortsMap,
        },
      });

      const flowNodes = container.querySelectorAll(".flow-node");
      expect(flowNodes).toHaveLength(2);

      // Each node should be rendered (checked via transform attributes being different)
      const transforms = Array.from(flowNodes).map((node) =>
        node.getAttribute("transform"),
      );
      expect(new Set(transforms).size).toBeGreaterThan(0);
    });
  });

  describe("edge rendering", () => {
    test("renders edges from connections", () => {
      const { container } = render(FlowCanvas, {
        props: {
          nodes: mockNodes,
          connections: mockConnections,
          portsMap: mockPortsMap,
        },
      });

      const edges = container.querySelectorAll(".flow-edge");
      expect(edges).toHaveLength(1);
    });

    test("edges are rendered before nodes (z-index)", () => {
      const { container } = render(FlowCanvas, {
        props: {
          nodes: mockNodes,
          connections: mockConnections,
          portsMap: mockPortsMap,
        },
      });

      const canvasContent = container.querySelector(".canvas-content");
      const children = Array.from(canvasContent?.children || []);

      // Find first edge and first node
      const firstEdgeIndex = children.findIndex((child) =>
        child.querySelector(".flow-edge"),
      );
      const firstNodeIndex = children.findIndex((child) =>
        child.querySelector(".flow-node"),
      );

      // Edges should come before nodes in DOM (rendered behind)
      if (firstEdgeIndex !== -1 && firstNodeIndex !== -1) {
        expect(firstEdgeIndex).toBeLessThan(firstNodeIndex);
      }
    });

    test("handles empty connections array", () => {
      const { container } = render(FlowCanvas, {
        props: {
          nodes: mockNodes,
          connections: [],
          portsMap: mockPortsMap,
        },
      });

      const edges = container.querySelectorAll(".flow-edge");
      expect(edges).toHaveLength(0);
    });

    test("filters out edges with missing nodes", () => {
      const invalidConnection: FlowConnection = {
        id: "conn-invalid",
        source_node_id: "missing-node",
        source_port: "out",
        target_node_id: "node-2",
        target_port: "in",
      };

      const { container } = render(FlowCanvas, {
        props: {
          nodes: mockNodes,
          connections: [...mockConnections, invalidConnection],
          portsMap: mockPortsMap,
        },
      });

      const edges = container.querySelectorAll(".flow-edge");
      // Should only render the valid connection
      expect(edges).toHaveLength(1);
    });
  });

  describe("zoom controls", () => {
    test("zoom controls are visible", () => {
      render(FlowCanvas, {
        props: {
          nodes: mockNodes,
          connections: mockConnections,
        },
      });

      expect(screen.getByLabelText("Zoom in")).toBeInTheDocument();
      expect(screen.getByLabelText("Zoom out")).toBeInTheDocument();
      expect(screen.getByLabelText("Fit to content")).toBeInTheDocument();
    });

    test("zoom in button has correct symbol", () => {
      render(FlowCanvas, {
        props: {
          nodes: mockNodes,
          connections: mockConnections,
        },
      });

      const zoomInButton = screen.getByLabelText("Zoom in");
      expect(zoomInButton).toHaveTextContent("+");
    });

    test("zoom out button has correct symbol", () => {
      render(FlowCanvas, {
        props: {
          nodes: mockNodes,
          connections: mockConnections,
        },
      });

      const zoomOutButton = screen.getByLabelText("Zoom out");
      expect(zoomOutButton).toHaveTextContent("−");
    });

    test("fit to content button has correct symbol", () => {
      render(FlowCanvas, {
        props: {
          nodes: mockNodes,
          connections: mockConnections,
        },
      });

      const fitButton = screen.getByLabelText("Fit to content");
      expect(fitButton).toHaveTextContent("⊡");
    });

    test("click on zoom in button triggers zoom", async () => {
      render(FlowCanvas, {
        props: {
          nodes: mockNodes,
          connections: mockConnections,
        },
      });

      const zoomInButton = screen.getByLabelText("Zoom in");
      await fireEvent.click(zoomInButton);

      // Button should be clickable (D3 zoom mock will be called)
      expect(zoomInButton).toBeInTheDocument();
    });

    test("click on zoom out button triggers zoom", async () => {
      render(FlowCanvas, {
        props: {
          nodes: mockNodes,
          connections: mockConnections,
        },
      });

      const zoomOutButton = screen.getByLabelText("Zoom out");
      await fireEvent.click(zoomOutButton);

      expect(zoomOutButton).toBeInTheDocument();
    });

    test("click on fit to content button triggers fit", async () => {
      render(FlowCanvas, {
        props: {
          nodes: mockNodes,
          connections: mockConnections,
        },
      });

      const fitButton = screen.getByLabelText("Fit to content");
      await fireEvent.click(fitButton);

      expect(fitButton).toBeInTheDocument();
    });
  });

  describe("node selection", () => {
    test("selected node has selected class", () => {
      const { container } = render(FlowCanvas, {
        props: {
          nodes: mockNodes,
          connections: mockConnections,
          portsMap: mockPortsMap,
          selectedNodeId: "node-1",
        },
      });

      const flowNodes = container.querySelectorAll(".flow-node");
      const selectedNodes = Array.from(flowNodes).filter((node) =>
        node.classList.contains("selected"),
      );

      expect(selectedNodes.length).toBeGreaterThan(0);
    });

    test("unselected nodes do not have selected class", () => {
      const { container } = render(FlowCanvas, {
        props: {
          nodes: mockNodes,
          connections: mockConnections,
          portsMap: mockPortsMap,
          selectedNodeId: "node-1",
        },
      });

      const flowNodes = container.querySelectorAll(".flow-node");
      const unselectedNodes = Array.from(flowNodes).filter(
        (node) => !node.classList.contains("selected"),
      );

      // At least one node should not be selected
      expect(unselectedNodes.length).toBeGreaterThan(0);
    });

    test("no nodes selected when selectedNodeId is null", () => {
      const { container } = render(FlowCanvas, {
        props: {
          nodes: mockNodes,
          connections: mockConnections,
          portsMap: mockPortsMap,
          selectedNodeId: null,
        },
      });

      const flowNodes = container.querySelectorAll(".flow-node");
      const selectedNodes = Array.from(flowNodes).filter((node) =>
        node.classList.contains("selected"),
      );

      expect(selectedNodes).toHaveLength(0);
    });
  });

  describe("node click interaction", () => {
    test("clicking node calls onNodeClick callback", async () => {
      const onNodeClickMock = vi.fn();

      const { container } = render(FlowCanvas, {
        props: {
          nodes: mockNodes,
          connections: mockConnections,
          portsMap: mockPortsMap,
          onNodeClick: onNodeClickMock,
        },
      });

      const firstNode = container.querySelector(".flow-node");
      expect(firstNode).toBeInTheDocument();

      await fireEvent.click(firstNode as Element);

      expect(onNodeClickMock).toHaveBeenCalled();
    });

    test("onNodeClick receives correct node ID", async () => {
      const onNodeClickMock = vi.fn();

      const { container } = render(FlowCanvas, {
        props: {
          nodes: mockNodes,
          connections: mockConnections,
          portsMap: mockPortsMap,
          onNodeClick: onNodeClickMock,
        },
      });

      const firstNode = container.querySelector(".flow-node");
      await fireEvent.click(firstNode as Element);

      // Should be called with a node ID
      expect(onNodeClickMock).toHaveBeenCalledWith(expect.any(String));
    });

    test("does not error when onNodeClick is not provided", async () => {
      const { container } = render(FlowCanvas, {
        props: {
          nodes: mockNodes,
          connections: mockConnections,
          portsMap: mockPortsMap,
        },
      });

      const firstNode = container.querySelector(".flow-node");

      // Should not throw
      await fireEvent.click(firstNode as Element);
    });
  });

  describe("grid pattern background", () => {
    test("renders grid pattern definition", () => {
      const { container } = render(FlowCanvas, {
        props: {
          nodes: mockNodes,
          connections: mockConnections,
        },
      });

      const pattern = container.querySelector("pattern#grid");
      expect(pattern).toBeInTheDocument();
    });

    test("grid pattern has correct dimensions", () => {
      const { container } = render(FlowCanvas, {
        props: {
          nodes: mockNodes,
          connections: mockConnections,
        },
      });

      const pattern = container.querySelector("pattern#grid");
      expect(pattern?.getAttribute("width")).toBe("20");
      expect(pattern?.getAttribute("height")).toBe("20");
    });

    test("background rectangle uses grid pattern", () => {
      const { container } = render(FlowCanvas, {
        props: {
          nodes: mockNodes,
          connections: mockConnections,
        },
      });

      const canvasContent = container.querySelector(".canvas-content");
      const backgroundRect = canvasContent?.querySelector(
        'rect[fill="url(#grid)"]',
      );

      expect(backgroundRect).toBeInTheDocument();
    });
  });

  describe("arrow marker definitions", () => {
    test("renders arrow marker definitions", () => {
      const { container } = render(FlowCanvas, {
        props: {
          nodes: mockNodes,
          connections: mockConnections,
        },
      });

      const defs = container.querySelector("defs");
      expect(defs).toBeInTheDocument();
    });

    test("defines default arrow marker", () => {
      const { container } = render(FlowCanvas, {
        props: {
          nodes: mockNodes,
          connections: mockConnections,
        },
      });

      const markers = container.querySelectorAll("marker");
      const markerIds = Array.from(markers).map((m) => m.id);

      expect(markerIds).toContain("arrow-default");
    });

    test("defines error arrow marker", () => {
      const { container } = render(FlowCanvas, {
        props: {
          nodes: mockNodes,
          connections: mockConnections,
        },
      });

      const markers = container.querySelectorAll("marker");
      const markerIds = Array.from(markers).map((m) => m.id);

      expect(markerIds).toContain("arrow-error");
    });

    test("defines warning arrow marker", () => {
      const { container } = render(FlowCanvas, {
        props: {
          nodes: mockNodes,
          connections: mockConnections,
        },
      });

      const markers = container.querySelectorAll("marker");
      const markerIds = Array.from(markers).map((m) => m.id);

      expect(markerIds).toContain("arrow-warning");
    });

    test("defines auto-discovered arrow marker", () => {
      const { container } = render(FlowCanvas, {
        props: {
          nodes: mockNodes,
          connections: mockConnections,
        },
      });

      const markers = container.querySelectorAll("marker");
      const markerIds = Array.from(markers).map((m) => m.id);

      expect(markerIds).toContain("arrow-auto");
    });
  });

  describe("zoom and pan transform", () => {
    test("canvas content has transform attribute", () => {
      const { container } = render(FlowCanvas, {
        props: {
          nodes: mockNodes,
          connections: mockConnections,
        },
      });

      const canvasContent = container.querySelector(".canvas-content");
      const transform = canvasContent?.getAttribute("transform");

      expect(transform).toBeTruthy();
      expect(transform).toMatch(/translate\([^)]+\)/);
      expect(transform).toMatch(/scale\([^)]+\)/);
    });

    test("initial transform has default values", () => {
      const { container } = render(FlowCanvas, {
        props: {
          nodes: mockNodes,
          connections: mockConnections,
        },
      });

      const canvasContent = container.querySelector(".canvas-content");
      const transform = canvasContent?.getAttribute("transform");

      // Should have translate and scale
      expect(transform).toContain("translate");
      expect(transform).toContain("scale");
    });
  });

  describe("ports map integration", () => {
    test("passes input ports to nodes", () => {
      const { container } = render(FlowCanvas, {
        props: {
          nodes: mockNodes,
          connections: mockConnections,
          portsMap: mockPortsMap,
        },
      });

      // Should render input ports for node-2
      const inputPorts = container.querySelectorAll(".port-input");
      expect(inputPorts.length).toBeGreaterThan(0);
    });

    test("passes output ports to nodes", () => {
      const { container } = render(FlowCanvas, {
        props: {
          nodes: mockNodes,
          connections: mockConnections,
          portsMap: mockPortsMap,
        },
      });

      // Should render output ports for node-1
      const outputPorts = container.querySelectorAll(".port-output");
      expect(outputPorts.length).toBeGreaterThan(0);
    });

    test("handles missing ports map for a node", () => {
      const incompletePorts = {
        "node-1": mockPortsMap["node-1"],
        // node-2 is missing
      };

      const { container } = render(FlowCanvas, {
        props: {
          nodes: mockNodes,
          connections: mockConnections,
          portsMap: incompletePorts,
        },
      });

      // Should still render nodes without error
      const flowNodes = container.querySelectorAll(".flow-node");
      expect(flowNodes).toHaveLength(2);
    });

    test("handles empty ports map", () => {
      const { container } = render(FlowCanvas, {
        props: {
          nodes: mockNodes,
          connections: mockConnections,
          portsMap: {},
        },
      });

      // Should render nodes with no ports
      const flowNodes = container.querySelectorAll(".flow-node");
      expect(flowNodes).toHaveLength(2);

      const ports = container.querySelectorAll(".port");
      expect(ports).toHaveLength(0);
    });
  });

  describe("complex flow scenarios", () => {
    test("handles flow with multiple branches", () => {
      const branchingNodes: FlowNode[] = [
        {
          id: "source",
          component: "input",
          type: "input",
          name: "Source",
          position: { x: 0, y: 0 },
          config: {},
        },
        {
          id: "branch-1",
          component: "transform",
          type: "processor",
          name: "Branch 1",
          position: { x: 0, y: 0 },
          config: {},
        },
        {
          id: "branch-2",
          component: "transform",
          type: "processor",
          name: "Branch 2",
          position: { x: 0, y: 0 },
          config: {},
        },
      ];

      const branchingConnections: FlowConnection[] = [
        {
          id: "conn-1",
          source_node_id: "source",
          source_port: "out",
          target_node_id: "branch-1",
          target_port: "in",
        },
        {
          id: "conn-2",
          source_node_id: "source",
          source_port: "out",
          target_node_id: "branch-2",
          target_port: "in",
        },
      ];

      const { container } = render(FlowCanvas, {
        props: {
          nodes: branchingNodes,
          connections: branchingConnections,
        },
      });

      const flowNodes = container.querySelectorAll(".flow-node");
      expect(flowNodes).toHaveLength(3);

      const edges = container.querySelectorAll(".flow-edge");
      expect(edges).toHaveLength(2);
    });

    test("handles large flow with many nodes", () => {
      const manyNodes: FlowNode[] = Array.from({ length: 20 }, (_, i) => ({
        id: `node-${i}`,
        component: "test",
        type: "processor",
        name: `Node ${i}`,
        position: { x: 0, y: 0 },
        config: {},
      }));

      const { container } = render(FlowCanvas, {
        props: {
          nodes: manyNodes,
          connections: [],
        },
      });

      const flowNodes = container.querySelectorAll(".flow-node");
      expect(flowNodes).toHaveLength(20);
    });
  });

  describe("E2E requirements", () => {
    test("Builder E2E: Verify flow canvas is interactive", async () => {
      // This test documents E2E requirements for the Builder agent
      // Builder should create E2E tests for:
      // 1. Zoom in/out functionality works correctly
      // 2. Pan gesture works across the canvas
      // 3. Clicking nodes opens edit modal
      // 4. Canvas adapts to viewport size
      // 5. Grid background renders correctly
      // 6. Edges are clickable with proper hitbox

      const onNodeClickMock = vi.fn();

      const { container } = render(FlowCanvas, {
        props: {
          nodes: mockNodes,
          connections: mockConnections,
          portsMap: mockPortsMap,
          onNodeClick: onNodeClickMock,
        },
      });

      // Verify zoom controls are functional
      const zoomInButton = screen.getByLabelText("Zoom in");
      expect(zoomInButton).toBeInTheDocument();
      await fireEvent.click(zoomInButton);

      // Verify nodes are clickable
      const firstNode = container.querySelector(".flow-node");
      await fireEvent.click(firstNode as Element);
      expect(onNodeClickMock).toHaveBeenCalled();
    });
  });
});
