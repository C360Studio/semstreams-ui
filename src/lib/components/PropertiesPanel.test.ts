// Code generated by Tester Agent. DO NOT EDIT.
// Task: PropertiesPanel UX Improvements
// Builder must make these tests pass without modification.

import { describe, it, expect, vi } from "vitest";
import { render, fireEvent } from "@testing-library/svelte";
import { tick } from "svelte";
import type { ComponentType } from "$lib/types/component";
import type { FlowNode } from "$lib/types/flow";
import PropertiesPanel from "./PropertiesPanel.svelte";

describe("PropertiesPanel - Collapsible Sections", () => {
  const createComponentTypeWithCategories = (): ComponentType => ({
    id: "test-component",
    name: "Test Component",
    type: "processor",
    protocol: "nats",
    category: "processor",
    description: "Test component with categorized fields",
    version: "1.0.0",
    schema: {
      type: "object",
      properties: {
        // Basic fields
        port: {
          type: "int",
          description: "Port number",
          category: "basic",
          minimum: 1,
          maximum: 65535,
        },
        bind_address: {
          type: "string",
          description: "Bind address",
          category: "basic",
        },
        enabled: {
          type: "bool",
          description: "Enable component",
          category: "basic",
        },
        // Advanced fields
        buffer_size: {
          type: "int",
          description: "Buffer size",
          category: "advanced",
          minimum: 1024,
        },
        timeout_seconds: {
          type: "int",
          description: "Timeout in seconds",
          category: "advanced",
        },
        // Field with no category (should default to advanced)
        log_level: {
          type: "enum",
          description: "Log level",
          enum: ["debug", "info", "warn", "error"],
        },
      },
      required: ["port"],
    },
  });

  const createNode = (componentType: ComponentType): FlowNode => ({
    id: "node-1",
    component: componentType.id,
    type: componentType.type,
    name: "Test Node",
    position: { x: 100, y: 100 },
    config: {
      port: 8080,
      bind_address: "0.0.0.0",
      enabled: true,
    },
  });

  it("should render basic fields in always-visible section", () => {
    const componentType = createComponentTypeWithCategories();
    const node = createNode(componentType);

    const { container } = render(PropertiesPanel, {
      props: {
        mode: "edit",
        node,
        nodeComponentType: componentType,
      },
    });

    // Basic fields section should exist and be visible
    const basicSection = container.querySelector(
      '[data-testid="basic-fields"]',
    );
    expect(basicSection).toBeInTheDocument();

    // Basic fields should be present
    expect(container.querySelector("#port")).toBeInTheDocument();
    expect(container.querySelector("#bind_address")).toBeInTheDocument();
    expect(container.querySelector("#enabled")).toBeInTheDocument();
  });

  it("should render advanced fields in collapsible details element", () => {
    const componentType = createComponentTypeWithCategories();
    const node = createNode(componentType);

    const { container } = render(PropertiesPanel, {
      props: {
        mode: "edit",
        node,
        nodeComponentType: componentType,
      },
    });

    // Advanced section should be a details element
    const advancedSection = container.querySelector(
      'details[data-testid="advanced-fields"]',
    );
    expect(advancedSection).toBeInTheDocument();

    // Should have summary element
    const summary = advancedSection?.querySelector("summary");
    expect(summary).toBeInTheDocument();
    expect(summary).toHaveTextContent(/advanced/i);
  });

  it("should treat fields without category as advanced", () => {
    const componentType = createComponentTypeWithCategories();
    const node = createNode(componentType);

    const { container } = render(PropertiesPanel, {
      props: {
        mode: "edit",
        node,
        nodeComponentType: componentType,
      },
    });

    // log_level has no category, should be in advanced section
    const advancedSection = container.querySelector(
      'details[data-testid="advanced-fields"]',
    );
    const logLevelField = advancedSection?.querySelector("#log_level");
    expect(logLevelField).toBeInTheDocument();
  });

  it("should sort fields alphabetically within each category", () => {
    const componentType: ComponentType = {
      id: "test",
      name: "Test",
      type: "processor",
      protocol: "nats",
      category: "processor",
      description: "Test",
      version: "1.0.0",
      schema: {
        type: "object",
        properties: {
          zebra_field: {
            type: "string",
            description: "Z field",
            category: "basic",
          },
          alpha_field: {
            type: "string",
            description: "A field",
            category: "basic",
          },
          beta_field: {
            type: "string",
            description: "B field",
            category: "basic",
          },
        },
        required: [],
      },
    };
    const node = createNode(componentType);

    const { container } = render(PropertiesPanel, {
      props: {
        mode: "edit",
        node,
        nodeComponentType: componentType,
      },
    });

    const basicSection = container.querySelector(
      '[data-testid="basic-fields"]',
    );
    const inputs = basicSection?.querySelectorAll('input[type="text"]');

    // Should be sorted: alpha, beta, zebra
    expect(inputs?.[0]).toHaveAttribute("id", "alpha_field");
    expect(inputs?.[1]).toHaveAttribute("id", "beta_field");
    expect(inputs?.[2]).toHaveAttribute("id", "zebra_field");
  });

  it("should expand/collapse advanced section on click", async () => {
    const componentType = createComponentTypeWithCategories();
    const node = createNode(componentType);

    const { container } = render(PropertiesPanel, {
      props: {
        mode: "edit",
        node,
        nodeComponentType: componentType,
      },
    });

    const advancedSection = container.querySelector(
      'details[data-testid="advanced-fields"]',
    ) as HTMLDetailsElement;
    const summary = advancedSection.querySelector("summary")!;

    // Initially closed
    expect(advancedSection.open).toBe(false);

    // Click to open
    await fireEvent.click(summary);
    await tick();

    expect(advancedSection.open).toBe(true);

    // Click to close
    await fireEvent.click(summary);
    await tick();

    expect(advancedSection.open).toBe(false);
  });

  it("should not render advanced section if no advanced fields", () => {
    const componentType: ComponentType = {
      id: "test",
      name: "Test",
      type: "processor",
      protocol: "nats",
      category: "processor",
      description: "Test",
      version: "1.0.0",
      schema: {
        type: "object",
        properties: {
          port: { type: "int", description: "Port", category: "basic" },
        },
        required: [],
      },
    };
    const node = createNode(componentType);

    const { container } = render(PropertiesPanel, {
      props: {
        mode: "edit",
        node,
        nodeComponentType: componentType,
      },
    });

    const advancedSection = container.querySelector(
      'details[data-testid="advanced-fields"]',
    );
    expect(advancedSection).not.toBeInTheDocument();
  });

  it("should not render basic section if no basic fields", () => {
    const componentType: ComponentType = {
      id: "test",
      name: "Test",
      type: "processor",
      protocol: "nats",
      category: "processor",
      description: "Test",
      version: "1.0.0",
      schema: {
        type: "object",
        properties: {
          buffer_size: {
            type: "int",
            description: "Buffer",
            category: "advanced",
          },
        },
        required: [],
      },
    };
    const node = createNode(componentType);

    const { container } = render(PropertiesPanel, {
      props: {
        mode: "edit",
        node,
        nodeComponentType: componentType,
      },
    });

    const basicSection = container.querySelector(
      '[data-testid="basic-fields"]',
    );
    expect(basicSection).not.toBeInTheDocument();
  });
});

describe("PropertiesPanel - Search/Filter", () => {
  const createComponentTypeWithManyFields = (): ComponentType => ({
    id: "test-component",
    name: "Test Component",
    type: "processor",
    protocol: "nats",
    category: "processor",
    description: "Test component",
    version: "1.0.0",
    schema: {
      type: "object",
      properties: {
        port: { type: "int", description: "Port number", category: "basic" },
        bind_address: {
          type: "string",
          description: "Network bind address",
          category: "basic",
        },
        buffer_size: {
          type: "int",
          description: "Buffer size in bytes",
          category: "advanced",
        },
        timeout: {
          type: "int",
          description: "Connection timeout",
          category: "advanced",
        },
        retry_count: {
          type: "int",
          description: "Number of retries",
          category: "advanced",
        },
      },
      required: [],
    },
  });

  const createNode = (componentType: ComponentType): FlowNode => ({
    id: "node-1",
    component: componentType.id,
    type: componentType.type,
    name: "Test Node",
    position: { x: 100, y: 100 },
    config: {},
  });

  it("should render search input above config fields", () => {
    const componentType = createComponentTypeWithManyFields();
    const node = createNode(componentType);

    const { container } = render(PropertiesPanel, {
      props: {
        mode: "edit",
        node,
        nodeComponentType: componentType,
      },
    });

    const searchInput = container.querySelector(
      'input[data-testid="field-search"]',
    ) as HTMLInputElement;
    expect(searchInput).toBeInTheDocument();
    expect(searchInput.type).toBe("text");
    expect(searchInput.placeholder).toMatch(/search/i);
  });

  it("should filter fields by name", async () => {
    const componentType = createComponentTypeWithManyFields();
    const node = createNode(componentType);

    const { container } = render(PropertiesPanel, {
      props: {
        mode: "edit",
        node,
        nodeComponentType: componentType,
      },
    });

    const searchInput = container.querySelector(
      'input[data-testid="field-search"]',
    ) as HTMLInputElement;

    // Type "port" to filter
    searchInput.value = "port";
    await fireEvent.input(searchInput);
    await tick();

    // Only port field should be visible
    expect(container.querySelector("#port")).toBeInTheDocument();
    expect(container.querySelector("#bind_address")).not.toBeInTheDocument();
    expect(container.querySelector("#buffer_size")).not.toBeInTheDocument();
  });

  it("should filter fields by description", async () => {
    const componentType = createComponentTypeWithManyFields();
    const node = createNode(componentType);

    const { container } = render(PropertiesPanel, {
      props: {
        mode: "edit",
        node,
        nodeComponentType: componentType,
      },
    });

    const searchInput = container.querySelector(
      'input[data-testid="field-search"]',
    ) as HTMLInputElement;

    // Search by description keyword
    searchInput.value = "network";
    await fireEvent.input(searchInput);
    await tick();

    // bind_address has "Network bind address" in description
    expect(container.querySelector("#bind_address")).toBeInTheDocument();
    expect(container.querySelector("#port")).not.toBeInTheDocument();
  });

  it("should be case-insensitive", async () => {
    const componentType = createComponentTypeWithManyFields();
    const node = createNode(componentType);

    const { container } = render(PropertiesPanel, {
      props: {
        mode: "edit",
        node,
        nodeComponentType: componentType,
      },
    });

    const searchInput = container.querySelector(
      'input[data-testid="field-search"]',
    ) as HTMLInputElement;

    searchInput.value = "PORT";
    await fireEvent.input(searchInput);
    await tick();

    expect(container.querySelector("#port")).toBeInTheDocument();
  });

  it("should ignore categories when searching", async () => {
    const componentType = createComponentTypeWithManyFields();
    const node = createNode(componentType);

    const { container } = render(PropertiesPanel, {
      props: {
        mode: "edit",
        node,
        nodeComponentType: componentType,
      },
    });

    const searchInput = container.querySelector(
      'input[data-testid="field-search"]',
    ) as HTMLInputElement;

    // Search for fields from both categories
    searchInput.value = "timeout";
    await fireEvent.input(searchInput);
    await tick();

    // Should show matching field regardless of category
    expect(container.querySelector("#timeout")).toBeInTheDocument();

    // Category sections should not be visible during search
    const basicSection = container.querySelector(
      '[data-testid="basic-fields"]',
    );
    const advancedSection = container.querySelector(
      'details[data-testid="advanced-fields"]',
    );

    // Sections should be hidden or not rendered during search
    expect(basicSection).not.toBeInTheDocument();
    expect(advancedSection).not.toBeInTheDocument();
  });

  it("should show clear button when search has text", async () => {
    const componentType = createComponentTypeWithManyFields();
    const node = createNode(componentType);

    const { container } = render(PropertiesPanel, {
      props: {
        mode: "edit",
        node,
        nodeComponentType: componentType,
      },
    });

    const searchInput = container.querySelector(
      'input[data-testid="field-search"]',
    ) as HTMLInputElement;
    const clearButton = container.querySelector(
      'button[data-testid="clear-search"]',
    ) as HTMLButtonElement;

    // Clear button should be disabled when empty
    expect(clearButton).toBeDisabled();

    // Type something
    searchInput.value = "port";
    await fireEvent.input(searchInput);
    await tick();

    // Clear button should be enabled
    expect(clearButton).not.toBeDisabled();
  });

  it("should reset filter when clear button clicked", async () => {
    const componentType = createComponentTypeWithManyFields();
    const node = createNode(componentType);

    const { container } = render(PropertiesPanel, {
      props: {
        mode: "edit",
        node,
        nodeComponentType: componentType,
      },
    });

    const searchInput = container.querySelector(
      'input[data-testid="field-search"]',
    ) as HTMLInputElement;
    const clearButton = container.querySelector(
      'button[data-testid="clear-search"]',
    ) as HTMLButtonElement;

    // Filter fields
    searchInput.value = "port";
    await fireEvent.input(searchInput);
    await tick();

    expect(container.querySelector("#bind_address")).not.toBeInTheDocument();

    // Click clear
    await fireEvent.click(clearButton);
    await tick();

    // All fields should be visible again
    expect(searchInput.value).toBe("");
    expect(container.querySelector("#port")).toBeInTheDocument();
    expect(container.querySelector("#bind_address")).toBeInTheDocument();
  });

  it("should show no results message when no fields match", async () => {
    const componentType = createComponentTypeWithManyFields();
    const node = createNode(componentType);

    const { container } = render(PropertiesPanel, {
      props: {
        mode: "edit",
        node,
        nodeComponentType: componentType,
      },
    });

    const searchInput = container.querySelector(
      'input[data-testid="field-search"]',
    ) as HTMLInputElement;

    // Search for non-existent field
    searchInput.value = "nonexistent_field";
    await fireEvent.input(searchInput);
    await tick();

    const noResults = container.querySelector(
      '[data-testid="no-search-results"]',
    );
    expect(noResults).toBeInTheDocument();
    expect(noResults).toHaveTextContent(/no.*fields.*match/i);
  });

  it("should show all fields when search is empty", async () => {
    const componentType = createComponentTypeWithManyFields();
    const node = createNode(componentType);

    const { container } = render(PropertiesPanel, {
      props: {
        mode: "edit",
        node,
        nodeComponentType: componentType,
      },
    });

    const searchInput = container.querySelector(
      'input[data-testid="field-search"]',
    ) as HTMLInputElement;

    // Initially all fields visible
    expect(container.querySelector("#port")).toBeInTheDocument();
    expect(container.querySelector("#bind_address")).toBeInTheDocument();

    // Filter
    searchInput.value = "port";
    await fireEvent.input(searchInput);
    await tick();

    expect(container.querySelector("#bind_address")).not.toBeInTheDocument();

    // Clear search manually
    searchInput.value = "";
    await fireEvent.input(searchInput);
    await tick();

    // All fields visible again
    expect(container.querySelector("#port")).toBeInTheDocument();
    expect(container.querySelector("#bind_address")).toBeInTheDocument();
  });
});

describe("PropertiesPanel - Field Name Humanization", () => {
  it("should display humanized field names as labels", () => {
    const componentType: ComponentType = {
      id: "test",
      name: "Test",
      type: "processor",
      protocol: "nats",
      category: "processor",
      description: "Test",
      version: "1.0.0",
      schema: {
        type: "object",
        properties: {
          bind_address: {
            type: "string",
            description: "Address",
            category: "basic",
          },
          udp_port: { type: "int", description: "Port", category: "basic" },
          max_buffer_size: {
            type: "int",
            description: "Buffer",
            category: "basic",
          },
        },
        required: [],
      },
    };

    const node: FlowNode = {
      id: "node-1",
      component: "test",
      type: "processor",
      name: "Test Node",
      position: { x: 100, y: 100 },
      config: {},
    };

    const { container } = render(PropertiesPanel, {
      props: {
        mode: "edit",
        node,
        nodeComponentType: componentType,
      },
    });

    // Field labels should be humanized
    const bindAddressLabel = container.querySelector(
      'label[for="bind_address"]',
    );
    expect(bindAddressLabel).toHaveTextContent("Bind Address");

    const udpPortLabel = container.querySelector('label[for="udp_port"]');
    expect(udpPortLabel).toHaveTextContent("UDP Port");

    const bufferLabel = container.querySelector('label[for="max_buffer_size"]');
    expect(bufferLabel).toHaveTextContent("Max Buffer Size");
  });

  it("should preserve acronyms in uppercase", () => {
    const componentType: ComponentType = {
      id: "test",
      name: "Test",
      type: "processor",
      protocol: "nats",
      category: "processor",
      description: "Test",
      version: "1.0.0",
      schema: {
        type: "object",
        properties: {
          ip_address: { type: "string", description: "IP", category: "basic" },
          http_timeout: {
            type: "int",
            description: "Timeout",
            category: "basic",
          },
          api_key: { type: "string", description: "Key", category: "basic" },
          ttl_seconds: { type: "int", description: "TTL", category: "basic" },
        },
        required: [],
      },
    };

    const node: FlowNode = {
      id: "node-1",
      component: "test",
      type: "processor",
      name: "Test Node",
      position: { x: 100, y: 100 },
      config: {},
    };

    const { container } = render(PropertiesPanel, {
      props: {
        mode: "edit",
        node,
        nodeComponentType: componentType,
      },
    });

    // Acronyms should stay uppercase
    expect(
      container.querySelector('label[for="ip_address"]'),
    ).toHaveTextContent("IP Address");
    expect(
      container.querySelector('label[for="http_timeout"]'),
    ).toHaveTextContent("HTTP Timeout");
    expect(container.querySelector('label[for="api_key"]')).toHaveTextContent(
      "API Key",
    );
    expect(
      container.querySelector('label[for="ttl_seconds"]'),
    ).toHaveTextContent("TTL Seconds");
  });
});

describe("PropertiesPanel - SchemaField Integration", () => {
  it("should use SchemaField component for string fields", () => {
    const componentType: ComponentType = {
      id: "test",
      name: "Test",
      type: "processor",
      protocol: "nats",
      category: "processor",
      description: "Test",
      version: "1.0.0",
      schema: {
        type: "object",
        properties: {
          name: {
            type: "string",
            description: "Name field",
            category: "basic",
          },
        },
        required: [],
      },
    };

    const node: FlowNode = {
      id: "node-1",
      component: "test",
      type: "processor",
      name: "Test Node",
      position: { x: 100, y: 100 },
      config: { name: "test" },
    };

    const { container } = render(PropertiesPanel, {
      props: {
        mode: "edit",
        node,
        nodeComponentType: componentType,
      },
    });

    // SchemaField should render StringField internally
    const input = container.querySelector("#name") as HTMLInputElement;
    expect(input).toBeInTheDocument();
    expect(input.type).toBe("text");
  });

  it("should use SchemaField component for int fields", () => {
    const componentType: ComponentType = {
      id: "test",
      name: "Test",
      type: "processor",
      protocol: "nats",
      category: "processor",
      description: "Test",
      version: "1.0.0",
      schema: {
        type: "object",
        properties: {
          port: {
            type: "int",
            description: "Port",
            category: "basic",
            minimum: 1,
            maximum: 65535,
          },
        },
        required: [],
      },
    };

    const node: FlowNode = {
      id: "node-1",
      component: "test",
      type: "processor",
      name: "Test Node",
      position: { x: 100, y: 100 },
      config: { port: 8080 },
    };

    const { container } = render(PropertiesPanel, {
      props: {
        mode: "edit",
        node,
        nodeComponentType: componentType,
      },
    });

    // SchemaField should render NumberField internally
    const input = container.querySelector("#port") as HTMLInputElement;
    expect(input).toBeInTheDocument();
    expect(input.type).toBe("number");
    expect(input.min).toBe("1");
    expect(input.max).toBe("65535");
  });

  it("should use SchemaField component for bool fields", () => {
    const componentType: ComponentType = {
      id: "test",
      name: "Test",
      type: "processor",
      protocol: "nats",
      category: "processor",
      description: "Test",
      version: "1.0.0",
      schema: {
        type: "object",
        properties: {
          enabled: { type: "bool", description: "Enabled", category: "basic" },
        },
        required: [],
      },
    };

    const node: FlowNode = {
      id: "node-1",
      component: "test",
      type: "processor",
      name: "Test Node",
      position: { x: 100, y: 100 },
      config: { enabled: true },
    };

    const { container } = render(PropertiesPanel, {
      props: {
        mode: "edit",
        node,
        nodeComponentType: componentType,
      },
    });

    // SchemaField should render BooleanField internally
    const input = container.querySelector("#enabled") as HTMLInputElement;
    expect(input).toBeInTheDocument();
    expect(input.type).toBe("checkbox");
  });

  it("should use SchemaField component for enum fields", () => {
    const componentType: ComponentType = {
      id: "test",
      name: "Test",
      type: "processor",
      protocol: "nats",
      category: "processor",
      description: "Test",
      version: "1.0.0",
      schema: {
        type: "object",
        properties: {
          log_level: {
            type: "enum",
            description: "Log level",
            category: "basic",
            enum: ["debug", "info", "warn", "error"],
          },
        },
        required: [],
      },
    };

    const node: FlowNode = {
      id: "node-1",
      component: "test",
      type: "processor",
      name: "Test Node",
      position: { x: 100, y: 100 },
      config: { log_level: "info" },
    };

    const { container } = render(PropertiesPanel, {
      props: {
        mode: "edit",
        node,
        nodeComponentType: componentType,
      },
    });

    // SchemaField should render EnumField internally
    const select = container.querySelector("#log_level") as HTMLSelectElement;
    expect(select).toBeInTheDocument();
    expect(select.tagName).toBe("SELECT");
  });

  it("should use SchemaField component for ports fields", () => {
    const componentType: ComponentType = {
      id: "test",
      name: "Test",
      type: "processor",
      protocol: "nats",
      category: "processor",
      description: "Test",
      version: "1.0.0",
      schema: {
        type: "object",
        properties: {
          ports: {
            type: "ports",
            description: "Port configuration",
            category: "basic",
            portFields: {
              name: { type: "string", editable: true },
              subject: { type: "string", editable: true },
            },
          },
        },
        required: [],
      },
    };

    const node: FlowNode = {
      id: "node-1",
      component: "test",
      type: "processor",
      name: "Test Node",
      position: { x: 100, y: 100 },
      config: {
        ports: {
          inputs: [],
          outputs: [],
        },
      },
    };

    const { container } = render(PropertiesPanel, {
      props: {
        mode: "edit",
        node,
        nodeComponentType: componentType,
      },
    });

    // SchemaField should render PortConfigEditor internally
    // PortConfigEditor has specific structure
    const portsSection = container.querySelector(
      '[data-testid="port-config-editor"]',
    );
    expect(portsSection).toBeInTheDocument();
  });

  it("should pass validation errors to SchemaField", async () => {
    const componentType: ComponentType = {
      id: "test",
      name: "Test",
      type: "processor",
      protocol: "nats",
      category: "processor",
      description: "Test",
      version: "1.0.0",
      schema: {
        type: "object",
        properties: {
          port: {
            type: "int",
            description: "Port",
            category: "basic",
            minimum: 1,
            maximum: 100,
          },
        },
        required: ["port"],
      },
    };

    const node: FlowNode = {
      id: "node-1",
      component: "test",
      type: "processor",
      name: "Test Node",
      position: { x: 100, y: 100 },
      config: { port: 200 }, // Invalid: exceeds maximum
    };

    const { container } = render(PropertiesPanel, {
      props: {
        mode: "edit",
        node,
        nodeComponentType: componentType,
      },
    });

    await tick();

    // Error should be displayed via SchemaField
    const errorEl = container.querySelector('.error, [role="alert"]');
    expect(errorEl).toBeInTheDocument();
    expect(errorEl?.textContent).toMatch(/100|maximum/i);
  });
});

describe("PropertiesPanel - Existing Functionality Preserved", () => {
  it("should still render empty state when mode is empty", () => {
    const { container } = render(PropertiesPanel, {
      props: {
        mode: "empty",
      },
    });

    const emptyState = container.querySelector(
      '[data-testid="properties-empty"]',
    );
    expect(emptyState).toBeInTheDocument();
    expect(emptyState).toHaveTextContent(/no selection/i);
  });

  it("should still render type preview when mode is type-preview", () => {
    const componentType: ComponentType = {
      id: "test",
      name: "Test Component",
      type: "processor",
      protocol: "nats",
      category: "processor",
      description: "Test description",
      version: "1.0.0",
    };

    const { container } = render(PropertiesPanel, {
      props: {
        mode: "type-preview",
        componentType,
      },
    });

    const preview = container.querySelector(
      '[data-testid="properties-type-preview"]',
    );
    expect(preview).toBeInTheDocument();
    expect(preview).toHaveTextContent("Test Component");
  });

  it("should still auto-save on blur", async () => {
    const onSave = vi.fn();
    const componentType: ComponentType = {
      id: "test",
      name: "Test",
      type: "processor",
      protocol: "nats",
      category: "processor",
      description: "Test",
      version: "1.0.0",
      schema: {
        type: "object",
        properties: {
          name: { type: "string", description: "Name", category: "basic" },
        },
        required: [],
      },
    };

    const node: FlowNode = {
      id: "node-1",
      component: "test",
      type: "processor",
      name: "Original Name",
      position: { x: 100, y: 100 },
      config: { name: "test" },
    };

    const { container } = render(PropertiesPanel, {
      props: {
        mode: "edit",
        node,
        nodeComponentType: componentType,
        onSave,
      },
    });

    const nameInput = container.querySelector("#name") as HTMLInputElement;
    nameInput.value = "New Value";
    await fireEvent.input(nameInput);
    await fireEvent.blur(nameInput);
    await tick();

    // Should auto-save on blur
    expect(onSave).toHaveBeenCalled();
  });

  it("should still show delete confirmation dialog", async () => {
    const onDelete = vi.fn();
    const componentType: ComponentType = {
      id: "test",
      name: "Test",
      type: "processor",
      protocol: "nats",
      category: "processor",
      description: "Test",
      version: "1.0.0",
      schema: {
        type: "object",
        properties: {},
        required: [],
      },
    };

    const node: FlowNode = {
      id: "node-1",
      component: "test",
      type: "processor",
      name: "Test Node",
      position: { x: 100, y: 100 },
      config: {},
    };

    const { container } = render(PropertiesPanel, {
      props: {
        mode: "edit",
        node,
        nodeComponentType: componentType,
        onDelete,
      },
    });

    const deleteButton = container.querySelector(
      ".btn-danger",
    ) as HTMLButtonElement;
    await fireEvent.click(deleteButton);
    await tick();

    const confirmDialog = container.querySelector(
      '[data-testid="delete-confirm"]',
    );
    expect(confirmDialog).toBeInTheDocument();
  });
});
