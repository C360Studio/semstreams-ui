// Code generated by Tester Agent. DO NOT EDIT.
// Task: Update AddComponentModal tests for two-step UI flow
// Builder must make these tests pass without modification.

import { describe, it, expect, vi, beforeEach } from "vitest";
import { render, fireEvent, waitFor } from "@testing-library/svelte";
import { tick } from "svelte";
import AddComponentModal from "./AddComponentModal.svelte";
import type { ComponentType } from "$lib/types/component";

describe("AddComponentModal", () => {
  const mockComponentTypes: ComponentType[] = [
    {
      id: "udp-input",
      name: "UDP Input",
      type: "input",
      protocol: "udp",
      category: "input",
      description: "Receives data over UDP protocol",
      version: "1.0.0",
      schema: {
        type: "object",
        properties: {
          port: {
            type: "number",
            description: "UDP port to listen on",
            default: 5000,
            minimum: 1024,
            maximum: 65535,
          },
          bufferSize: {
            type: "number",
            description: "Buffer size in bytes",
            default: 1024,
          },
        },
        required: ["port"],
      },
    },
    {
      id: "nats-processor",
      name: "NATS Processor",
      type: "processor",
      protocol: "nats",
      category: "processor",
      description: "Processes messages from NATS",
      version: "1.0.0",
      schema: {
        type: "object",
        properties: {
          subject: {
            type: "string",
            description: "NATS subject pattern",
            default: "data.*",
          },
          workers: {
            type: "number",
            description: "Number of worker threads",
            default: 4,
            minimum: 1,
            maximum: 16,
          },
        },
        required: ["subject"],
      },
    },
    {
      id: "websocket-output",
      name: "WebSocket Output",
      type: "output",
      protocol: "websocket",
      category: "output",
      description: "Sends data via WebSocket",
      version: "1.0.0",
      schema: {
        type: "object",
        properties: {
          endpoint: {
            type: "string",
            description: "WebSocket endpoint URL",
            default: "ws://localhost:8080",
          },
        },
        required: ["endpoint"],
      },
    },
  ];

  // Mock fetch globally for ComponentPalette
  beforeEach(() => {
    global.fetch = vi.fn().mockResolvedValue({
      ok: true,
      json: async () => mockComponentTypes,
    });
  });

  // Test 1: DOM Output - Rendering States
  describe("DOM Output - Rendering States", () => {
    it("should not render when isOpen is false", () => {
      const { container } = render(AddComponentModal, {
        props: {
          isOpen: false,
          componentTypes: mockComponentTypes,
          onAdd: vi.fn(),
          onClose: vi.fn(),
        },
      });

      expect(
        container.querySelector('[role="dialog"]'),
      ).not.toBeInTheDocument();
    });

    it("should render dialog when isOpen is true", () => {
      const { container } = render(AddComponentModal, {
        props: {
          isOpen: true,
          componentTypes: mockComponentTypes,
          onAdd: vi.fn(),
          onClose: vi.fn(),
        },
      });

      const dialog = container.querySelector('[role="dialog"]');
      expect(dialog).toBeInTheDocument();
    });

    it("should render correct dialog title", () => {
      const { container } = render(AddComponentModal, {
        props: {
          isOpen: true,
          componentTypes: mockComponentTypes,
          onAdd: vi.fn(),
          onClose: vi.fn(),
        },
      });

      const title = container.querySelector("#dialog-title");
      expect(title).toBeInTheDocument();
      expect(title).toHaveTextContent("Add Component");
    });

    it("should render ComponentPalette when no type is selected", async () => {
      const { container } = render(AddComponentModal, {
        props: {
          isOpen: true,
          componentTypes: mockComponentTypes,
          onAdd: vi.fn(),
          onClose: vi.fn(),
        },
      });

      await tick();

      // ComponentPalette should be visible
      const paletteContainer = container.querySelector(".palette-container");
      expect(paletteContainer).toBeInTheDocument();
    });

    it("should NOT render name input initially (before type selection)", () => {
      const { container } = render(AddComponentModal, {
        props: {
          isOpen: true,
          componentTypes: mockComponentTypes,
          onAdd: vi.fn(),
          onClose: vi.fn(),
        },
      });

      const nameInput = container.querySelector('input[name="name"]');
      expect(nameInput).not.toBeInTheDocument();
    });

    it("should NOT render Add Component button initially", () => {
      const { container } = render(AddComponentModal, {
        props: {
          isOpen: true,
          componentTypes: mockComponentTypes,
          onAdd: vi.fn(),
          onClose: vi.fn(),
        },
      });

      const buttons = container.querySelectorAll("button");
      const addButton = Array.from(buttons).find((btn) =>
        btn.textContent?.includes("Add Component"),
      );

      expect(addButton).toBeUndefined();
    });

    it("should render Cancel and close buttons", () => {
      const { container } = render(AddComponentModal, {
        props: {
          isOpen: true,
          componentTypes: mockComponentTypes,
          onAdd: vi.fn(),
          onClose: vi.fn(),
        },
      });

      const buttons = container.querySelectorAll("button");
      const cancelButton = Array.from(buttons).find((btn) =>
        btn.textContent?.includes("Cancel"),
      );

      expect(cancelButton).toBeInTheDocument();

      const closeButton = container.querySelector(".close-button");
      expect(closeButton).toBeInTheDocument();
      expect(closeButton).toHaveAttribute("aria-label", "Close dialog");
    });
  });

  // Test 2: Component Type Selection (Two-Step Flow)
  describe("Component Type Selection", () => {
    it("should show config form after component card is clicked", async () => {
      const { container } = render(AddComponentModal, {
        props: {
          isOpen: true,
          componentTypes: mockComponentTypes,
          onAdd: vi.fn(),
          onClose: vi.fn(),
        },
      });

      await tick();
      await waitFor(() => {
        expect(
          container.querySelector('[data-component-id="udp-input"]'),
        ).toBeInTheDocument();
      });

      // Click UDP Input component card
      const componentCard = container.querySelector(
        '[data-component-id="udp-input"]',
      ) as HTMLElement;
      await fireEvent.dblClick(componentCard);
      await tick();

      // Config form should now be visible
      const nameInput = container.querySelector('input[name="name"]');
      expect(nameInput).toBeInTheDocument();
    });

    it("should auto-generate default name when component type selected", async () => {
      const { container } = render(AddComponentModal, {
        props: {
          isOpen: true,
          componentTypes: mockComponentTypes,
          onAdd: vi.fn(),
          onClose: vi.fn(),
        },
      });

      await tick();
      await waitFor(() => {
        expect(
          container.querySelector('[data-component-id="udp-input"]'),
        ).toBeInTheDocument();
      });

      // Click component card
      const componentCard = container.querySelector(
        '[data-component-id="udp-input"]',
      ) as HTMLElement;
      await fireEvent.dblClick(componentCard);
      await tick();

      const nameInput = container.querySelector(
        'input[name="name"]',
      ) as HTMLInputElement;

      // Should auto-populate name
      expect(nameInput.value).toMatch(/^udp-input-\d+$/);
    });

    it("should show component-specific config fields when type selected", async () => {
      const { container } = render(AddComponentModal, {
        props: {
          isOpen: true,
          componentTypes: mockComponentTypes,
          onAdd: vi.fn(),
          onClose: vi.fn(),
        },
      });

      await tick();
      await waitFor(() => {
        expect(
          container.querySelector('[data-component-id="udp-input"]'),
        ).toBeInTheDocument();
      });

      // Select UDP Input
      const componentCard = container.querySelector(
        '[data-component-id="udp-input"]',
      ) as HTMLElement;
      await fireEvent.dblClick(componentCard);
      await tick();

      // Should show config fields from schema
      const portInput = container.querySelector('input[name="config.port"]');
      const bufferInput = container.querySelector(
        'input[name="config.bufferSize"]',
      );

      expect(portInput).toBeInTheDocument();
      expect(bufferInput).toBeInTheDocument();
    });

    it("should populate config fields with default values", async () => {
      const { container } = render(AddComponentModal, {
        props: {
          isOpen: true,
          componentTypes: mockComponentTypes,
          onAdd: vi.fn(),
          onClose: vi.fn(),
        },
      });

      await tick();
      await waitFor(() => {
        expect(
          container.querySelector('[data-component-id="udp-input"]'),
        ).toBeInTheDocument();
      });

      // Select UDP Input
      const componentCard = container.querySelector(
        '[data-component-id="udp-input"]',
      ) as HTMLElement;
      await fireEvent.dblClick(componentCard);
      await tick();

      // Should show default values
      const portInput = container.querySelector(
        'input[name="config.port"]',
      ) as HTMLInputElement;
      const bufferInput = container.querySelector(
        'input[name="config.bufferSize"]',
      ) as HTMLInputElement;

      expect(portInput.value).toBe("5000");
      expect(bufferInput.value).toBe("1024");
    });

    it("should display selected component name", async () => {
      const { container } = render(AddComponentModal, {
        props: {
          isOpen: true,
          componentTypes: mockComponentTypes,
          onAdd: vi.fn(),
          onClose: vi.fn(),
        },
      });

      await tick();
      await waitFor(() => {
        expect(
          container.querySelector('[data-component-id="udp-input"]'),
        ).toBeInTheDocument();
      });

      // Select UDP Input
      const componentCard = container.querySelector(
        '[data-component-id="udp-input"]',
      ) as HTMLElement;
      await fireEvent.dblClick(componentCard);
      await tick();

      // Should show selected type display
      const selectedType = container.querySelector(".selected-type");
      expect(selectedType).toBeInTheDocument();
      expect(selectedType).toHaveTextContent("UDP Input");
    });

    it("should show back button after type selection", async () => {
      const { container } = render(AddComponentModal, {
        props: {
          isOpen: true,
          componentTypes: mockComponentTypes,
          onAdd: vi.fn(),
          onClose: vi.fn(),
        },
      });

      await tick();
      await waitFor(() => {
        expect(
          container.querySelector('[data-component-id="udp-input"]'),
        ).toBeInTheDocument();
      });

      // Initially no back button
      expect(container.querySelector(".back-button")).not.toBeInTheDocument();

      // Select component
      const componentCard = container.querySelector(
        '[data-component-id="udp-input"]',
      ) as HTMLElement;
      await fireEvent.dblClick(componentCard);
      await tick();

      // Back button should appear
      const backButton = container.querySelector(".back-button");
      expect(backButton).toBeInTheDocument();
    });

    it("should return to palette when back button is clicked", async () => {
      const { container } = render(AddComponentModal, {
        props: {
          isOpen: true,
          componentTypes: mockComponentTypes,
          onAdd: vi.fn(),
          onClose: vi.fn(),
        },
      });

      await tick();
      await waitFor(() => {
        expect(
          container.querySelector('[data-component-id="udp-input"]'),
        ).toBeInTheDocument();
      });

      // Select component
      const componentCard = container.querySelector(
        '[data-component-id="udp-input"]',
      ) as HTMLElement;
      await fireEvent.dblClick(componentCard);
      await tick();

      // Config form visible
      expect(container.querySelector('input[name="name"]')).toBeInTheDocument();

      // Click back button
      const backButton = container.querySelector(
        ".back-button",
      ) as HTMLButtonElement;
      await fireEvent.click(backButton);
      await tick();

      // Should return to palette
      expect(container.querySelector(".palette-container")).toBeInTheDocument();
      expect(
        container.querySelector('input[name="name"]'),
      ).not.toBeInTheDocument();
    });

    it("should reset name when selecting same component type again", async () => {
      const { container } = render(AddComponentModal, {
        props: {
          isOpen: true,
          componentTypes: mockComponentTypes,
          onAdd: vi.fn(),
          onClose: vi.fn(),
        },
      });

      await tick();
      await waitFor(() => {
        expect(
          container.querySelector('[data-component-id="udp-input"]'),
        ).toBeInTheDocument();
      });

      // Select component first time
      const componentCard = container.querySelector(
        '[data-component-id="udp-input"]',
      ) as HTMLElement;
      await fireEvent.dblClick(componentCard);

      // Wait for config form to appear
      await waitFor(() => {
        expect(
          container.querySelector('input[name="name"]'),
        ).toBeInTheDocument();
      });

      const nameInput = container.querySelector(
        'input[name="name"]',
      ) as HTMLInputElement;
      const firstGeneratedName = nameInput.value;

      // Verify it's auto-generated
      expect(firstGeneratedName).toMatch(/^udp-input-\d+$/);
    });
  });

  // Test 3: Form Validation
  describe("Form Validation", () => {
    it("should NOT show Add button when no component type selected", () => {
      const { container } = render(AddComponentModal, {
        props: {
          isOpen: true,
          componentTypes: mockComponentTypes,
          onAdd: vi.fn(),
          onClose: vi.fn(),
        },
      });

      const buttons = container.querySelectorAll("button");
      const addButton = Array.from(buttons).find((btn) =>
        btn.textContent?.includes("Add Component"),
      );

      expect(addButton).toBeUndefined();
    });

    it("should disable Add button when name is empty", async () => {
      const { container } = render(AddComponentModal, {
        props: {
          isOpen: true,
          componentTypes: mockComponentTypes,
          onAdd: vi.fn(),
          onClose: vi.fn(),
        },
      });

      await tick();
      await waitFor(() => {
        expect(
          container.querySelector('[data-component-id="udp-input"]'),
        ).toBeInTheDocument();
      });

      // Select component type
      const componentCard = container.querySelector(
        '[data-component-id="udp-input"]',
      ) as HTMLElement;
      await fireEvent.dblClick(componentCard);
      await tick();

      const nameInput = container.querySelector(
        'input[name="name"]',
      ) as HTMLInputElement;

      // Clear the auto-generated name
      await fireEvent.input(nameInput, { target: { value: "" } });
      await tick();

      const buttons = container.querySelectorAll("button");
      const addButton = Array.from(buttons).find((btn) =>
        btn.textContent?.includes("Add Component"),
      ) as HTMLButtonElement;

      expect(addButton).toBeDisabled();
    });

    it("should disable Add button when required config field is empty", async () => {
      const { container } = render(AddComponentModal, {
        props: {
          isOpen: true,
          componentTypes: mockComponentTypes,
          onAdd: vi.fn(),
          onClose: vi.fn(),
        },
      });

      await tick();
      await waitFor(() => {
        expect(
          container.querySelector('[data-component-id="udp-input"]'),
        ).toBeInTheDocument();
      });

      // Select UDP Input (port is required)
      const componentCard = container.querySelector(
        '[data-component-id="udp-input"]',
      ) as HTMLElement;
      await fireEvent.dblClick(componentCard);
      await tick();

      const portInput = container.querySelector(
        'input[name="config.port"]',
      ) as HTMLInputElement;

      // Clear required field
      await fireEvent.input(portInput, { target: { value: "" } });
      await tick();

      const buttons = container.querySelectorAll("button");
      const addButton = Array.from(buttons).find((btn) =>
        btn.textContent?.includes("Add Component"),
      ) as HTMLButtonElement;

      expect(addButton).toBeDisabled();
    });

    it("should enable Add button when all required fields are valid", async () => {
      const { container } = render(AddComponentModal, {
        props: {
          isOpen: true,
          componentTypes: mockComponentTypes,
          onAdd: vi.fn(),
          onClose: vi.fn(),
        },
      });

      await tick();
      await waitFor(() => {
        expect(
          container.querySelector('[data-component-id="udp-input"]'),
        ).toBeInTheDocument();
      });

      // Select component type (auto-generates name and default config)
      const componentCard = container.querySelector(
        '[data-component-id="udp-input"]',
      ) as HTMLElement;
      await fireEvent.dblClick(componentCard);
      await tick();

      const buttons = container.querySelectorAll("button");
      const addButton = Array.from(buttons).find((btn) =>
        btn.textContent?.includes("Add Component"),
      ) as HTMLButtonElement;

      expect(addButton).not.toBeDisabled();
    });

    it("should show validation error for invalid number input", async () => {
      const { container } = render(AddComponentModal, {
        props: {
          isOpen: true,
          componentTypes: mockComponentTypes,
          onAdd: vi.fn(),
          onClose: vi.fn(),
        },
      });

      await tick();
      await waitFor(() => {
        expect(
          container.querySelector('[data-component-id="udp-input"]'),
        ).toBeInTheDocument();
      });

      // Select UDP Input
      const componentCard = container.querySelector(
        '[data-component-id="udp-input"]',
      ) as HTMLElement;
      await fireEvent.dblClick(componentCard);
      await tick();

      const portInput = container.querySelector(
        'input[name="config.port"]',
      ) as HTMLInputElement;

      // Enter value below minimum
      await fireEvent.input(portInput, { target: { value: "500" } });
      await tick();

      // Should show validation error
      const errorMessage = container.querySelector(".validation-error");
      expect(errorMessage).toBeInTheDocument();
      expect(errorMessage).toHaveTextContent(/minimum.*1024/i);
    });

    it("should show validation error for value above maximum", async () => {
      const { container } = render(AddComponentModal, {
        props: {
          isOpen: true,
          componentTypes: mockComponentTypes,
          onAdd: vi.fn(),
          onClose: vi.fn(),
        },
      });

      await tick();
      await waitFor(() => {
        expect(
          container.querySelector('[data-component-id="udp-input"]'),
        ).toBeInTheDocument();
      });

      // Select UDP Input
      const componentCard = container.querySelector(
        '[data-component-id="udp-input"]',
      ) as HTMLElement;
      await fireEvent.dblClick(componentCard);
      await tick();

      const portInput = container.querySelector(
        'input[name="config.port"]',
      ) as HTMLInputElement;

      // Enter value above maximum
      await fireEvent.input(portInput, { target: { value: "70000" } });
      await tick();

      // Should show validation error
      const errorMessage = container.querySelector(".validation-error");
      expect(errorMessage).toBeInTheDocument();
      expect(errorMessage).toHaveTextContent(/maximum.*65535/i);
    });
  });

  // Test 4: User Actions
  describe("User Actions", () => {
    it("should call onClose when Cancel button clicked", async () => {
      const onClose = vi.fn();
      const { container } = render(AddComponentModal, {
        props: {
          isOpen: true,
          componentTypes: mockComponentTypes,
          onAdd: vi.fn(),
          onClose,
        },
      });

      const buttons = container.querySelectorAll("button");
      const cancelButton = Array.from(buttons).find((btn) =>
        btn.textContent?.includes("Cancel"),
      ) as HTMLButtonElement;

      await fireEvent.click(cancelButton);

      expect(onClose).toHaveBeenCalledTimes(1);
    });

    it("should call onClose when close button (X) clicked", async () => {
      const onClose = vi.fn();
      const { container } = render(AddComponentModal, {
        props: {
          isOpen: true,
          componentTypes: mockComponentTypes,
          onAdd: vi.fn(),
          onClose,
        },
      });

      const closeButton = container.querySelector(
        ".close-button",
      ) as HTMLButtonElement;

      await fireEvent.click(closeButton);

      expect(onClose).toHaveBeenCalledTimes(1);
    });

    it("should call onClose when clicking outside dialog (background)", async () => {
      const onClose = vi.fn();
      const { container } = render(AddComponentModal, {
        props: {
          isOpen: true,
          componentTypes: mockComponentTypes,
          onAdd: vi.fn(),
          onClose,
        },
      });

      const overlay = container.querySelector(".dialog-overlay") as HTMLElement;

      // Click on overlay background
      await fireEvent.click(overlay);

      expect(onClose).toHaveBeenCalledTimes(1);
    });

    it("should NOT close when clicking inside dialog content", async () => {
      const onClose = vi.fn();
      const { container } = render(AddComponentModal, {
        props: {
          isOpen: true,
          componentTypes: mockComponentTypes,
          onAdd: vi.fn(),
          onClose,
        },
      });

      const dialogContent = container.querySelector(
        ".dialog-content",
      ) as HTMLElement;

      // Click inside dialog content
      await fireEvent.click(dialogContent);

      expect(onClose).not.toHaveBeenCalled();
    });

    it("should call onAdd with correct data when Add button clicked", async () => {
      const onAdd = vi.fn();
      const { container } = render(AddComponentModal, {
        props: {
          isOpen: true,
          componentTypes: mockComponentTypes,
          onAdd,
          onClose: vi.fn(),
        },
      });

      await tick();
      await waitFor(() => {
        expect(
          container.querySelector('[data-component-id="udp-input"]'),
        ).toBeInTheDocument();
      });

      // Select component type
      const componentCard = container.querySelector(
        '[data-component-id="udp-input"]',
      ) as HTMLElement;
      await fireEvent.dblClick(componentCard);
      await tick();

      const nameInput = container.querySelector(
        'input[name="name"]',
      ) as HTMLInputElement;

      // Customize name
      await fireEvent.input(nameInput, { target: { value: "my-udp-input" } });
      await tick();

      // Customize config
      const portInput = container.querySelector(
        'input[name="config.port"]',
      ) as HTMLInputElement;
      await fireEvent.input(portInput, { target: { value: "8000" } });
      await tick();

      // Click Add button
      const buttons = container.querySelectorAll("button");
      const addButton = Array.from(buttons).find((btn) =>
        btn.textContent?.includes("Add Component"),
      ) as HTMLButtonElement;
      await fireEvent.click(addButton);

      // Verify onAdd called with correct data
      expect(onAdd).toHaveBeenCalledTimes(1);
      expect(onAdd).toHaveBeenCalledWith(
        mockComponentTypes[0], // UDP Input component type
        "my-udp-input",
        {
          port: 8000,
          bufferSize: 1024,
        },
      );
    });

    it("should reset form when Add is successful", async () => {
      const onAdd = vi.fn();
      const { container } = render(AddComponentModal, {
        props: {
          isOpen: true,
          componentTypes: mockComponentTypes,
          onAdd,
          onClose: vi.fn(),
        },
      });

      await tick();
      await waitFor(() => {
        expect(
          container.querySelector('[data-component-id="udp-input"]'),
        ).toBeInTheDocument();
      });

      // Select component type
      const componentCard = container.querySelector(
        '[data-component-id="udp-input"]',
      ) as HTMLElement;
      await fireEvent.dblClick(componentCard);
      await tick();

      // Click Add button
      const buttons = container.querySelectorAll("button");
      const addButton = Array.from(buttons).find((btn) =>
        btn.textContent?.includes("Add Component"),
      ) as HTMLButtonElement;
      await fireEvent.click(addButton);
      await tick();

      // Should return to palette view
      expect(container.querySelector(".palette-container")).toBeInTheDocument();
      expect(
        container.querySelector('input[name="name"]'),
      ).not.toBeInTheDocument();
    });

    it("should hide modal when closed", async () => {
      const { container, rerender } = render(AddComponentModal, {
        props: {
          isOpen: true,
          componentTypes: mockComponentTypes,
          onAdd: vi.fn(),
          onClose: vi.fn(),
        },
      });

      await tick();

      // Verify modal is open
      expect(container.querySelector('[role="dialog"]')).toBeInTheDocument();

      // Close modal
      await rerender({ isOpen: false });
      await tick();

      // Verify modal is closed
      expect(
        container.querySelector('[role="dialog"]'),
      ).not.toBeInTheDocument();

      // Reopen modal
      await rerender({ isOpen: true });
      await tick();

      // Verify modal is open again
      expect(container.querySelector('[role="dialog"]')).toBeInTheDocument();
    });
  });

  // Test 5: Keyboard Navigation
  describe("Keyboard Navigation", () => {
    it("should close dialog when ESC key pressed", async () => {
      const onClose = vi.fn();
      render(AddComponentModal, {
        props: {
          isOpen: true,
          componentTypes: mockComponentTypes,
          onAdd: vi.fn(),
          onClose,
        },
      });

      // Simulate ESC key press
      const escEvent = new KeyboardEvent("keydown", { key: "Escape" });
      window.dispatchEvent(escEvent);

      await tick();

      expect(onClose).toHaveBeenCalledTimes(1);
    });

    it("should NOT close when other keys pressed", async () => {
      const onClose = vi.fn();
      render(AddComponentModal, {
        props: {
          isOpen: true,
          componentTypes: mockComponentTypes,
          onAdd: vi.fn(),
          onClose,
        },
      });

      // Simulate other key presses
      const enterEvent = new KeyboardEvent("keydown", { key: "Enter" });
      window.dispatchEvent(enterEvent);

      const spaceEvent = new KeyboardEvent("keydown", { key: " " });
      window.dispatchEvent(spaceEvent);

      await tick();

      expect(onClose).not.toHaveBeenCalled();
    });

    it("should NOT trigger ESC handler when dialog is closed", async () => {
      const onClose = vi.fn();
      render(AddComponentModal, {
        props: {
          isOpen: false,
          componentTypes: mockComponentTypes,
          onAdd: vi.fn(),
          onClose,
        },
      });

      // Simulate ESC key press
      const escEvent = new KeyboardEvent("keydown", { key: "Escape" });
      window.dispatchEvent(escEvent);

      await tick();

      expect(onClose).not.toHaveBeenCalled();
    });

    it("should allow keyboard selection of component card", async () => {
      const { container } = render(AddComponentModal, {
        props: {
          isOpen: true,
          componentTypes: mockComponentTypes,
          onAdd: vi.fn(),
          onClose: vi.fn(),
        },
      });

      await tick();
      await waitFor(() => {
        expect(
          container.querySelector('[data-component-id="udp-input"]'),
        ).toBeInTheDocument();
      });

      // Get component card
      const componentCard = container.querySelector(
        '[data-component-id="udp-input"]',
      ) as HTMLElement;

      // Simulate Enter key press
      await fireEvent.keyDown(componentCard, { key: "Enter" });
      await tick();

      // Should show config form
      expect(container.querySelector('input[name="name"]')).toBeInTheDocument();
    });
  });

  // Test 6: Accessibility
  describe("Accessibility", () => {
    it("should have proper ARIA attributes", () => {
      const { container } = render(AddComponentModal, {
        props: {
          isOpen: true,
          componentTypes: mockComponentTypes,
          onAdd: vi.fn(),
          onClose: vi.fn(),
        },
      });

      const dialog = container.querySelector('[role="dialog"]');
      expect(dialog).toHaveAttribute("aria-modal", "true");
      expect(dialog).toHaveAttribute("aria-labelledby", "dialog-title");

      const title = container.querySelector("#dialog-title");
      expect(title).toBeInTheDocument();
      expect(title).toHaveTextContent("Add Component");
    });

    it("should have aria-label on close button", () => {
      const { container } = render(AddComponentModal, {
        props: {
          isOpen: true,
          componentTypes: mockComponentTypes,
          onAdd: vi.fn(),
          onClose: vi.fn(),
        },
      });

      const closeButton = container.querySelector(".close-button");
      expect(closeButton).toHaveAttribute("aria-label", "Close dialog");
    });

    it("should have proper label associations for form fields after type selection", async () => {
      const { container } = render(AddComponentModal, {
        props: {
          isOpen: true,
          componentTypes: mockComponentTypes,
          onAdd: vi.fn(),
          onClose: vi.fn(),
        },
      });

      await tick();
      await waitFor(() => {
        expect(
          container.querySelector('[data-component-id="udp-input"]'),
        ).toBeInTheDocument();
      });

      // Select component
      const componentCard = container.querySelector(
        '[data-component-id="udp-input"]',
      ) as HTMLElement;
      await fireEvent.dblClick(componentCard);
      await tick();

      // Name field
      const nameLabel = container.querySelector('label[for="name"]');
      const nameInput = container.querySelector("#name");
      expect(nameLabel).toBeInTheDocument();
      expect(nameInput).toBeInTheDocument();
    });

    it("should mark required fields with aria-required", async () => {
      const { container } = render(AddComponentModal, {
        props: {
          isOpen: true,
          componentTypes: mockComponentTypes,
          onAdd: vi.fn(),
          onClose: vi.fn(),
        },
      });

      await tick();
      await waitFor(() => {
        expect(
          container.querySelector('[data-component-id="udp-input"]'),
        ).toBeInTheDocument();
      });

      // Select component
      const componentCard = container.querySelector(
        '[data-component-id="udp-input"]',
      ) as HTMLElement;
      await fireEvent.dblClick(componentCard);
      await tick();

      const nameInput = container.querySelector('input[name="name"]');
      expect(nameInput).toHaveAttribute("aria-required", "true");
    });

    it("should have aria-invalid on fields with validation errors", async () => {
      const { container } = render(AddComponentModal, {
        props: {
          isOpen: true,
          componentTypes: mockComponentTypes,
          onAdd: vi.fn(),
          onClose: vi.fn(),
        },
      });

      await tick();
      await waitFor(() => {
        expect(
          container.querySelector('[data-component-id="udp-input"]'),
        ).toBeInTheDocument();
      });

      // Select UDP Input
      const componentCard = container.querySelector(
        '[data-component-id="udp-input"]',
      ) as HTMLElement;
      await fireEvent.dblClick(componentCard);
      await tick();

      const portInput = container.querySelector(
        'input[name="config.port"]',
      ) as HTMLInputElement;

      // Enter invalid value
      await fireEvent.input(portInput, { target: { value: "500" } });
      await tick();

      expect(portInput).toHaveAttribute("aria-invalid", "true");
    });

    it("should have accessible component cards", async () => {
      const { container } = render(AddComponentModal, {
        props: {
          isOpen: true,
          componentTypes: mockComponentTypes,
          onAdd: vi.fn(),
          onClose: vi.fn(),
        },
      });

      await tick();
      await waitFor(() => {
        expect(
          container.querySelector('[data-component-id="udp-input"]'),
        ).toBeInTheDocument();
      });

      const componentCard = container.querySelector(
        '[data-component-id="udp-input"]',
      );

      // Should have role and be keyboard accessible
      expect(componentCard).toHaveAttribute("role", "button");
      expect(componentCard).toHaveAttribute("tabindex", "0");
      expect(componentCard).toHaveAttribute("aria-label");
    });
  });

  // Test 7: Reactivity
  describe("Reactivity", () => {
    it("should update when isOpen changes", async () => {
      const { container, rerender } = render(AddComponentModal, {
        props: {
          isOpen: false,
          componentTypes: mockComponentTypes,
          onAdd: vi.fn(),
          onClose: vi.fn(),
        },
      });

      // Initially not visible
      expect(
        container.querySelector('[role="dialog"]'),
      ).not.toBeInTheDocument();

      // Open modal
      await rerender({ isOpen: true });
      await tick();

      // Now visible
      expect(container.querySelector('[role="dialog"]')).toBeInTheDocument();
    });

    it("should update when componentTypes change", async () => {
      const { rerender } = render(AddComponentModal, {
        props: {
          isOpen: true,
          componentTypes: [mockComponentTypes[0]],
          onAdd: vi.fn(),
          onClose: vi.fn(),
        },
      });

      await tick();

      // Add more component types
      await rerender({ componentTypes: mockComponentTypes });
      await tick();

      // ComponentPalette fetches its own data, so this mainly tests that prop changes don't crash
      expect(true).toBe(true);
    });
  });

  // Test 8: Edge Cases
  describe("Edge Cases", () => {
    it("should handle component type without schema", async () => {
      const componentWithoutSchema: ComponentType = {
        id: "simple-component",
        name: "Simple Component",
        type: "processor",
        protocol: "nats",
        category: "processor",
        description: "Simple component without config schema",
        version: "1.0.0",
      };

      // Mock fetch to return component without schema
      global.fetch = vi.fn().mockResolvedValue({
        ok: true,
        json: async () => [componentWithoutSchema],
      });

      const { container } = render(AddComponentModal, {
        props: {
          isOpen: true,
          componentTypes: [componentWithoutSchema],
          onAdd: vi.fn(),
          onClose: vi.fn(),
        },
      });

      await tick();
      await waitFor(() => {
        expect(
          container.querySelector('[data-component-id="simple-component"]'),
        ).toBeInTheDocument();
      });

      // Select component
      const componentCard = container.querySelector(
        '[data-component-id="simple-component"]',
      ) as HTMLElement;
      await fireEvent.dblClick(componentCard);
      await tick();

      // Should show name input but not config section
      expect(container.querySelector('input[name="name"]')).toBeInTheDocument();
      expect(
        container.querySelector(".config-section"),
      ).not.toBeInTheDocument();
    });

    it("should handle missing onAdd callback", async () => {
      const { container } = render(AddComponentModal, {
        props: {
          isOpen: true,
          componentTypes: mockComponentTypes,
          onClose: vi.fn(),
        },
      });

      await tick();
      await waitFor(() => {
        expect(
          container.querySelector('[data-component-id="udp-input"]'),
        ).toBeInTheDocument();
      });

      // Select component type
      const componentCard = container.querySelector(
        '[data-component-id="udp-input"]',
      ) as HTMLElement;
      await fireEvent.dblClick(componentCard);
      await tick();

      const buttons = container.querySelectorAll("button");
      const addButton = Array.from(buttons).find((btn) =>
        btn.textContent?.includes("Add Component"),
      ) as HTMLButtonElement;

      // Should not throw error when clicking Add
      expect(() => fireEvent.click(addButton)).not.toThrow();
    });

    it("should handle missing onClose callback", async () => {
      const { container } = render(AddComponentModal, {
        props: {
          isOpen: true,
          componentTypes: mockComponentTypes,
          onAdd: vi.fn(),
        },
      });

      const buttons = container.querySelectorAll("button");
      const cancelButton = Array.from(buttons).find((btn) =>
        btn.textContent?.includes("Cancel"),
      ) as HTMLButtonElement;

      // Should not throw error when clicking Cancel
      expect(() => fireEvent.click(cancelButton)).not.toThrow();
    });

    it("should sanitize auto-generated names", async () => {
      const componentWithSpecialChars: ComponentType = {
        id: "special-component-@#$",
        name: "Special Component @#$",
        type: "processor",
        protocol: "nats",
        category: "processor",
        description: "Component with special characters",
        version: "1.0.0",
      };

      global.fetch = vi.fn().mockResolvedValue({
        ok: true,
        json: async () => [componentWithSpecialChars],
      });

      const { container } = render(AddComponentModal, {
        props: {
          isOpen: true,
          componentTypes: [componentWithSpecialChars],
          onAdd: vi.fn(),
          onClose: vi.fn(),
        },
      });

      await tick();
      await waitFor(() => {
        expect(
          container.querySelector(
            '[data-component-id="special-component-@#$"]',
          ),
        ).toBeInTheDocument();
      });

      // Select component
      const componentCard = container.querySelector(
        '[data-component-id="special-component-@#$"]',
      ) as HTMLElement;
      await fireEvent.dblClick(componentCard);
      await tick();

      const nameInput = container.querySelector(
        'input[name="name"]',
      ) as HTMLInputElement;

      // Name should be sanitized (alphanumeric, dashes, underscores only)
      expect(nameInput.value).toMatch(/^[a-z0-9-_]+$/);
    });

    it("should handle ComponentPalette fetch error gracefully", async () => {
      // Mock fetch to fail
      global.fetch = vi.fn().mockRejectedValue(new Error("Network error"));

      const { container } = render(AddComponentModal, {
        props: {
          isOpen: true,
          componentTypes: mockComponentTypes,
          onAdd: vi.fn(),
          onClose: vi.fn(),
        },
      });

      await tick();

      // ComponentPalette should show error, not crash
      // The modal itself should still render
      expect(container.querySelector('[role="dialog"]')).toBeInTheDocument();
    });
  });
});
