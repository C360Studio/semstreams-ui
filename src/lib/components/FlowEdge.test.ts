// Code generated by Tester Agent. DO NOT EDIT.
// Task: Sprint 1 - D3 Canvas component tests (FlowEdge.svelte)
// Builder must make these tests pass without modification.

import { describe, test, expect } from "vitest";
import { render } from "@testing-library/svelte";
import FlowEdge from "./FlowEdge.svelte";
import type { LayoutEdge } from "$lib/utils/d3-layout";
import type { FlowConnection } from "$lib/types/flow";

describe("FlowEdge", () => {
  const mockConnection: FlowConnection = {
    id: "conn-1",
    source_node_id: "node-a",
    source_port: "out",
    target_node_id: "node-b",
    target_port: "in",
  };

  const mockEdge: LayoutEdge = {
    id: "edge-1",
    sourceNodeId: "node-a",
    sourcePort: "out",
    targetNodeId: "node-b",
    targetPort: "in",
    sourceX: 250,
    sourceY: 90,
    targetX: 350,
    targetY: 90,
    original: mockConnection,
  };

  describe("basic rendering", () => {
    test("renders edge with correct class", () => {
      const { container } = render(FlowEdge, {
        props: {
          edge: mockEdge,
        },
      });

      const edgeGroup = container.querySelector(".flow-edge");
      expect(edgeGroup).toBeInTheDocument();
    });

    test("renders visible path element", () => {
      const { container } = render(FlowEdge, {
        props: {
          edge: mockEdge,
        },
      });

      const visiblePath = container.querySelector(".edge-path");
      expect(visiblePath).toBeInTheDocument();
    });

    test("renders invisible hitbox path for easier clicking", () => {
      const { container } = render(FlowEdge, {
        props: {
          edge: mockEdge,
        },
      });

      const hitbox = container.querySelector(".edge-hitbox");
      expect(hitbox).toBeInTheDocument();
      expect(hitbox?.getAttribute("stroke")).toBe("transparent");
      expect(hitbox?.getAttribute("stroke-width")).toBe("20");
    });

    test("path has correct d attribute", () => {
      const { container } = render(FlowEdge, {
        props: {
          edge: mockEdge,
        },
      });

      const path = container.querySelector(".edge-path");
      const dAttr = path?.getAttribute("d");

      expect(dAttr).toBeTruthy();
      expect(dAttr).toContain("M"); // Should start with Move command
    });
  });

  describe("validation state styling", () => {
    test("applies correct stroke color for valid state", () => {
      const validEdge: LayoutEdge = {
        ...mockEdge,
        original: {
          ...mockConnection,
          validationState: "valid",
        },
      };

      const { container } = render(FlowEdge, {
        props: {
          edge: validEdge,
        },
      });

      const path = container.querySelector(".edge-path");
      const stroke = path?.getAttribute("stroke");

      // Should use primary color for valid connections
      expect(stroke).toBeTruthy();
    });

    test("applies correct stroke color for error state", () => {
      const errorEdge: LayoutEdge = {
        ...mockEdge,
        original: {
          ...mockConnection,
          validationState: "error",
          validationMessage: "Type mismatch",
        },
      };

      const { container } = render(FlowEdge, {
        props: {
          edge: errorEdge,
        },
      });

      const path = container.querySelector(".edge-path");
      const stroke = path?.getAttribute("stroke");

      // Should use error color
      expect(stroke).toBeTruthy();
    });

    test("applies correct stroke color for warning state", () => {
      const warningEdge: LayoutEdge = {
        ...mockEdge,
        original: {
          ...mockConnection,
          validationState: "warning",
          validationMessage: "Performance concern",
        },
      };

      const { container } = render(FlowEdge, {
        props: {
          edge: warningEdge,
        },
      });

      const path = container.querySelector(".edge-path");
      const stroke = path?.getAttribute("stroke");

      // Should use warning color
      expect(stroke).toBeTruthy();
    });
  });

  describe("auto-discovered connection styling", () => {
    test("applies dashed stroke for auto-discovered edges", () => {
      const autoEdge: LayoutEdge = {
        ...mockEdge,
        original: {
          ...mockConnection,
          source: "auto",
        },
      };

      const { container } = render(FlowEdge, {
        props: {
          edge: autoEdge,
        },
      });

      const edgeGroup = container.querySelector(".flow-edge");
      expect(edgeGroup).toHaveClass("auto");
    });

    test("manual connections do not have auto class", () => {
      const manualEdge: LayoutEdge = {
        ...mockEdge,
        original: {
          ...mockConnection,
          source: "manual",
        },
      };

      const { container } = render(FlowEdge, {
        props: {
          edge: manualEdge,
        },
      });

      const edgeGroup = container.querySelector(".flow-edge");
      expect(edgeGroup).not.toHaveClass("auto");
    });

    test("connections without source property are treated as manual", () => {
      const { container } = render(FlowEdge, {
        props: {
          edge: mockEdge,
        },
      });

      const edgeGroup = container.querySelector(".flow-edge");
      expect(edgeGroup).not.toHaveClass("auto");
    });
  });

  describe("error indicator rendering", () => {
    test("shows error indicator at midpoint for error state", () => {
      const errorEdge: LayoutEdge = {
        ...mockEdge,
        original: {
          ...mockConnection,
          validationState: "error",
          validationMessage: "Port type mismatch",
        },
      };

      const { container } = render(FlowEdge, {
        props: {
          edge: errorEdge,
        },
      });

      const indicator = container.querySelector(".edge-status-indicator");
      expect(indicator).toBeInTheDocument();

      const icon = container.querySelector(".edge-status-icon");
      expect(icon).toHaveTextContent("!");
    });

    test("shows warning indicator at midpoint for warning state", () => {
      const warningEdge: LayoutEdge = {
        ...mockEdge,
        original: {
          ...mockConnection,
          validationState: "warning",
          validationMessage: "Potential performance issue",
        },
      };

      const { container } = render(FlowEdge, {
        props: {
          edge: warningEdge,
        },
      });

      const indicator = container.querySelector(".edge-status-indicator");
      expect(indicator).toBeInTheDocument();

      const icon = container.querySelector(".edge-status-icon");
      expect(icon).toHaveTextContent("?");
    });

    test("does not show indicator for valid state", () => {
      const validEdge: LayoutEdge = {
        ...mockEdge,
        original: {
          ...mockConnection,
          validationState: "valid",
        },
      };

      const { container } = render(FlowEdge, {
        props: {
          edge: validEdge,
        },
      });

      const indicator = container.querySelector(".edge-status-indicator");
      expect(indicator).not.toBeInTheDocument();
    });

    test("error indicator positioned at midpoint", () => {
      const errorEdge: LayoutEdge = {
        ...mockEdge,
        sourceX: 100,
        sourceY: 100,
        targetX: 300,
        targetY: 200,
        original: {
          ...mockConnection,
          validationState: "error",
        },
      };

      const { container } = render(FlowEdge, {
        props: {
          edge: errorEdge,
        },
      });

      const indicatorGroup = container.querySelector(
        'g[transform*="translate"]',
      );
      const transform = indicatorGroup?.getAttribute("transform");

      // Midpoint X: (100 + 300) / 2 = 200
      // Midpoint Y: (100 + 200) / 2 = 150
      expect(transform).toContain("200");
      expect(transform).toContain("150");
    });

    test("validation message shown in title element", () => {
      const errorEdge: LayoutEdge = {
        ...mockEdge,
        original: {
          ...mockConnection,
          validationState: "error",
          validationMessage: "Type mismatch: expected string, got number",
        },
      };

      const { container } = render(FlowEdge, {
        props: {
          edge: errorEdge,
        },
      });

      const title = container.querySelector("title");
      expect(title).toBeInTheDocument();
      expect(title?.textContent).toBe(
        "Type mismatch: expected string, got number",
      );
    });
  });

  describe("selected state", () => {
    test("applies selected class when selected=true", () => {
      const { container } = render(FlowEdge, {
        props: {
          edge: mockEdge,
          selected: true,
        },
      });

      const edgeGroup = container.querySelector(".flow-edge");
      expect(edgeGroup).toHaveClass("selected");
    });

    test("does not apply selected class when selected=false", () => {
      const { container } = render(FlowEdge, {
        props: {
          edge: mockEdge,
          selected: false,
        },
      });

      const edgeGroup = container.querySelector(".flow-edge");
      expect(edgeGroup).not.toHaveClass("selected");
    });

    test("selected defaults to false", () => {
      const { container } = render(FlowEdge, {
        props: {
          edge: mockEdge,
        },
      });

      const edgeGroup = container.querySelector(".flow-edge");
      expect(edgeGroup).not.toHaveClass("selected");
    });
  });

  describe("arrow marker", () => {
    test("uses default marker ID by default", () => {
      const { container } = render(FlowEdge, {
        props: {
          edge: mockEdge,
        },
      });

      const path = container.querySelector(".edge-path");
      const markerEnd = path?.getAttribute("marker-end");

      expect(markerEnd).toBe("url(#arrow)");
    });

    test("uses custom marker ID when provided", () => {
      const { container } = render(FlowEdge, {
        props: {
          edge: mockEdge,
          markerId: "custom-arrow",
        },
      });

      const path = container.querySelector(".edge-path");
      const markerEnd = path?.getAttribute("marker-end");

      expect(markerEnd).toBe("url(#custom-arrow)");
    });
  });

  describe("edge path variations", () => {
    test("handles horizontal edge", () => {
      const horizontalEdge: LayoutEdge = {
        ...mockEdge,
        sourceX: 100,
        sourceY: 100,
        targetX: 300,
        targetY: 100,
      };

      const { container } = render(FlowEdge, {
        props: {
          edge: horizontalEdge,
        },
      });

      const path = container.querySelector(".edge-path");
      expect(path?.getAttribute("d")).toBeTruthy();
    });

    test("handles vertical edge", () => {
      const verticalEdge: LayoutEdge = {
        ...mockEdge,
        sourceX: 100,
        sourceY: 100,
        targetX: 100,
        targetY: 300,
      };

      const { container } = render(FlowEdge, {
        props: {
          edge: verticalEdge,
        },
      });

      const path = container.querySelector(".edge-path");
      expect(path?.getAttribute("d")).toBeTruthy();
    });

    test("handles diagonal edge", () => {
      const diagonalEdge: LayoutEdge = {
        ...mockEdge,
        sourceX: 100,
        sourceY: 100,
        targetX: 300,
        targetY: 300,
      };

      const { container } = render(FlowEdge, {
        props: {
          edge: diagonalEdge,
        },
      });

      const path = container.querySelector(".edge-path");
      expect(path?.getAttribute("d")).toBeTruthy();
    });

    test("handles backward edge (target left of source)", () => {
      const backwardEdge: LayoutEdge = {
        ...mockEdge,
        sourceX: 300,
        sourceY: 100,
        targetX: 100,
        targetY: 200,
      };

      const { container } = render(FlowEdge, {
        props: {
          edge: backwardEdge,
        },
      });

      const path = container.querySelector(".edge-path");
      expect(path?.getAttribute("d")).toBeTruthy();
    });
  });

  describe("edge styling attributes", () => {
    test("path has no fill", () => {
      const { container } = render(FlowEdge, {
        props: {
          edge: mockEdge,
        },
      });

      const path = container.querySelector(".edge-path");
      expect(path?.getAttribute("fill")).toBe("none");
    });

    test("hitbox has no fill", () => {
      const { container } = render(FlowEdge, {
        props: {
          edge: mockEdge,
        },
      });

      const hitbox = container.querySelector(".edge-hitbox");
      expect(hitbox?.getAttribute("fill")).toBe("none");
    });

    test("path has stroke-width attribute", () => {
      const { container } = render(FlowEdge, {
        props: {
          edge: mockEdge,
        },
      });

      const path = container.querySelector(".edge-path");
      const strokeWidth = path?.getAttribute("stroke-width");

      expect(strokeWidth).toBeTruthy();
    });

    test("auto-discovered edges have dashed stroke pattern", () => {
      const autoEdge: LayoutEdge = {
        ...mockEdge,
        original: {
          ...mockConnection,
          source: "auto",
        },
      };

      const { container } = render(FlowEdge, {
        props: {
          edge: autoEdge,
        },
      });

      const path = container.querySelector(".edge-path");
      const dashArray = path?.getAttribute("stroke-dasharray");

      // Should have a dasharray value for dashed lines
      expect(dashArray).toBeTruthy();
    });
  });

  describe("complex validation scenarios", () => {
    test("handles error with empty validation message", () => {
      const errorEdge: LayoutEdge = {
        ...mockEdge,
        original: {
          ...mockConnection,
          validationState: "error",
          validationMessage: "",
        },
      };

      const { container } = render(FlowEdge, {
        props: {
          edge: errorEdge,
        },
      });

      const indicator = container.querySelector(".edge-status-indicator");
      expect(indicator).toBeInTheDocument();

      // Should still render indicator even without message
      const icon = container.querySelector(".edge-status-icon");
      expect(icon).toHaveTextContent("!");
    });

    test("handles warning without validation message", () => {
      const warningEdge: LayoutEdge = {
        ...mockEdge,
        original: {
          ...mockConnection,
          validationState: "warning",
        },
      };

      const { container } = render(FlowEdge, {
        props: {
          edge: warningEdge,
        },
      });

      const indicator = container.querySelector(".edge-status-indicator");
      expect(indicator).toBeInTheDocument();
    });

    test("handles unknown validation state gracefully", () => {
      const unknownEdge: LayoutEdge = {
        ...mockEdge,
        original: {
          ...mockConnection,
          validationState: "unknown" as unknown as
            | "valid"
            | "warning"
            | "error",
        },
      };

      // Should render without throwing
      const { container } = render(FlowEdge, {
        props: {
          edge: unknownEdge,
        },
      });

      const edgeGroup = container.querySelector(".flow-edge");
      expect(edgeGroup).toBeInTheDocument();
    });
  });
});
