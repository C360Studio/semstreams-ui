// Code generated by Tester Agent. DO NOT EDIT.
// Task: Sprint 1 - D3 Canvas component tests (FlowNode.svelte)
// Builder must make these tests pass without modification.

import { describe, test, expect, vi } from "vitest";
import { render, fireEvent } from "@testing-library/svelte";
import FlowNode from "./FlowNode.svelte";
import type { LayoutNode } from "$lib/utils/d3-layout";
import type { ValidatedPort } from "$lib/types/port";

describe("FlowNode", () => {
  const mockNode: LayoutNode = {
    id: "test-node-1",
    type: "udp-input",
    name: "UDP Input",
    x: 100,
    y: 200,
    width: 200,
    height: 80,
    config: { port: 5000 },
    original: {
      id: "test-node-1",
      type: "udp-input",
      name: "UDP Input",
      position: { x: 0, y: 0 },
      config: { port: 5000 },
    },
  };

  const mockInputPorts: ValidatedPort[] = [
    {
      name: "data_in",
      direction: "input",
      type: "message.Storable",
      required: true,
      connection_id: "nats.subject.data",
      pattern: "stream",
      description: "Data input stream",
    },
    {
      name: "control_in",
      direction: "input",
      type: "control.Signal",
      required: false,
      connection_id: "nats.subject.control",
      pattern: "request",
      description: "Control input",
    },
  ];

  const mockOutputPorts: ValidatedPort[] = [
    {
      name: "data_out",
      direction: "output",
      type: "message.Storable",
      required: true,
      connection_id: "nats.subject.output",
      pattern: "stream",
      description: "Data output stream",
    },
  ];

  describe("basic rendering", () => {
    test("renders node with correct position transform", () => {
      const { container } = render(FlowNode, {
        props: {
          node: mockNode,
          inputPorts: [],
          outputPorts: [],
        },
      });

      const nodeGroup = container.querySelector(".flow-node");
      expect(nodeGroup).toBeInTheDocument();
      expect(nodeGroup?.getAttribute("transform")).toBe("translate(100, 200)");
    });

    test("displays node name", () => {
      const { container } = render(FlowNode, {
        props: {
          node: mockNode,
          inputPorts: [],
          outputPorts: [],
        },
      });

      const label = container.querySelector(".node-label");
      expect(label).toHaveTextContent("UDP Input");
    });

    test("displays node type", () => {
      const { container } = render(FlowNode, {
        props: {
          node: mockNode,
          inputPorts: [],
          outputPorts: [],
        },
      });

      const typeLabel = container.querySelector(".node-type");
      expect(typeLabel).toHaveTextContent("udp-input");
    });

    test("shows port count summary", () => {
      const { container } = render(FlowNode, {
        props: {
          node: mockNode,
          inputPorts: mockInputPorts,
          outputPorts: mockOutputPorts,
        },
      });

      const summary = container.querySelector(".port-summary");
      expect(summary).toHaveTextContent("2 in, 1 out");
    });

    test("renders node background rectangle", () => {
      const { container } = render(FlowNode, {
        props: {
          node: mockNode,
          inputPorts: [],
          outputPorts: [],
        },
      });

      const background = container.querySelector(".node-background");
      expect(background).toBeInTheDocument();
      expect(background?.getAttribute("width")).toBe("200");
      expect(background?.getAttribute("height")).toBe("80");
      expect(background?.getAttribute("rx")).toBe("8");
    });
  });

  describe("port rendering", () => {
    test("renders input ports on left side", () => {
      const { container } = render(FlowNode, {
        props: {
          node: mockNode,
          inputPorts: mockInputPorts,
          outputPorts: [],
        },
      });

      const inputPortCircles = container.querySelectorAll(".port-input");
      expect(inputPortCircles).toHaveLength(2);

      // First port should be at x=0 (left side)
      expect(inputPortCircles[0].getAttribute("cx")).toBe("0");
      // Y position should be 30 for first port
      expect(inputPortCircles[0].getAttribute("cy")).toBe("30");

      // Second port at x=0, y=50 (30 + 20 spacing)
      expect(inputPortCircles[1].getAttribute("cx")).toBe("0");
      expect(inputPortCircles[1].getAttribute("cy")).toBe("50");
    });

    test("renders output ports on right side", () => {
      const { container } = render(FlowNode, {
        props: {
          node: mockNode,
          inputPorts: [],
          outputPorts: mockOutputPorts,
        },
      });

      const outputPortCircles = container.querySelectorAll(".port-output");
      expect(outputPortCircles).toHaveLength(1);

      // Output port should be at x=200 (right side = node.width)
      expect(outputPortCircles[0].getAttribute("cx")).toBe("200");
      expect(outputPortCircles[0].getAttribute("cy")).toBe("30");
    });

    test("required ports are filled with color", () => {
      const { container } = render(FlowNode, {
        props: {
          node: mockNode,
          inputPorts: mockInputPorts,
          outputPorts: [],
        },
      });

      const requiredPort = container.querySelector(".port-input");
      expect(requiredPort?.getAttribute("fill")).not.toBe(
        "var(--pico-background-color)",
      );
    });

    test("optional ports have background fill", () => {
      const { container } = render(FlowNode, {
        props: {
          node: mockNode,
          inputPorts: mockInputPorts,
          outputPorts: [],
        },
      });

      const ports = container.querySelectorAll(".port-input");
      const optionalPort = ports[1]; // Second port is optional

      expect(optionalPort?.getAttribute("fill")).toBe(
        "var(--pico-background-color)",
      );
    });

    test("ports have title elements for tooltips", () => {
      const { container } = render(FlowNode, {
        props: {
          node: mockNode,
          inputPorts: mockInputPorts,
          outputPorts: [],
        },
      });

      const firstPort = container.querySelector(".port-input");
      const title = firstPort?.querySelector("title");

      expect(title).toBeInTheDocument();
      expect(title?.textContent).toContain("data_in");
      expect(title?.textContent).toContain("required");
    });

    test("handles empty port arrays gracefully", () => {
      const { container } = render(FlowNode, {
        props: {
          node: mockNode,
          inputPorts: [],
          outputPorts: [],
        },
      });

      const ports = container.querySelectorAll(".port");
      expect(ports).toHaveLength(0);

      const summary = container.querySelector(".port-summary");
      expect(summary).toHaveTextContent("0 in, 0 out");
    });
  });

  describe("domain color accent", () => {
    test("renders domain accent bar", () => {
      const { container } = render(FlowNode, {
        props: {
          node: mockNode,
          inputPorts: [],
          outputPorts: [],
        },
      });

      const accent = container.querySelector(".node-accent");
      expect(accent).toBeInTheDocument();
      expect(accent?.getAttribute("width")).toBe("4");
    });

    test("accent bar has correct height", () => {
      const { container } = render(FlowNode, {
        props: {
          node: mockNode,
          inputPorts: [],
          outputPorts: [],
        },
      });

      const accent = container.querySelector(".node-accent");
      expect(accent?.getAttribute("height")).toBe("80");
    });
  });

  describe("click interaction", () => {
    test("calls onclick callback when clicked", async () => {
      const onclickMock = vi.fn();

      const { container } = render(FlowNode, {
        props: {
          node: mockNode,
          inputPorts: [],
          outputPorts: [],
          onclick: onclickMock,
        },
      });

      const nodeGroup = container.querySelector(".flow-node");
      expect(nodeGroup).toBeInTheDocument();

      await fireEvent.click(nodeGroup as Element);

      expect(onclickMock).toHaveBeenCalledTimes(1);
      expect(onclickMock).toHaveBeenCalledWith("test-node-1");
    });

    test("handles Enter key press", async () => {
      const onclickMock = vi.fn();

      const { container } = render(FlowNode, {
        props: {
          node: mockNode,
          inputPorts: [],
          outputPorts: [],
          onclick: onclickMock,
        },
      });

      const nodeGroup = container.querySelector(".flow-node");
      expect(nodeGroup).toBeInTheDocument();

      await fireEvent.keyDown(nodeGroup as Element, { key: "Enter" });

      expect(onclickMock).toHaveBeenCalledTimes(1);
      expect(onclickMock).toHaveBeenCalledWith("test-node-1");
    });

    test("handles Space key press", async () => {
      const onclickMock = vi.fn();

      const { container } = render(FlowNode, {
        props: {
          node: mockNode,
          inputPorts: [],
          outputPorts: [],
          onclick: onclickMock,
        },
      });

      const nodeGroup = container.querySelector(".flow-node");
      expect(nodeGroup).toBeInTheDocument();

      await fireEvent.keyDown(nodeGroup as Element, { key: " " });

      expect(onclickMock).toHaveBeenCalledTimes(1);
      expect(onclickMock).toHaveBeenCalledWith("test-node-1");
    });

    test("does not call onclick when callback is not provided", async () => {
      const { container } = render(FlowNode, {
        props: {
          node: mockNode,
          inputPorts: [],
          outputPorts: [],
        },
      });

      const nodeGroup = container.querySelector(".flow-node");

      // Should not throw
      await fireEvent.click(nodeGroup as Element);
    });
  });

  describe("selected state", () => {
    test("applies selected class when selected=true", () => {
      const { container } = render(FlowNode, {
        props: {
          node: mockNode,
          inputPorts: [],
          outputPorts: [],
          selected: true,
        },
      });

      const nodeGroup = container.querySelector(".flow-node");
      expect(nodeGroup).toHaveClass("selected");
    });

    test("does not apply selected class when selected=false", () => {
      const { container } = render(FlowNode, {
        props: {
          node: mockNode,
          inputPorts: [],
          outputPorts: [],
          selected: false,
        },
      });

      const nodeGroup = container.querySelector(".flow-node");
      expect(nodeGroup).not.toHaveClass("selected");
    });

    test("selected defaults to false", () => {
      const { container } = render(FlowNode, {
        props: {
          node: mockNode,
          inputPorts: [],
          outputPorts: [],
        },
      });

      const nodeGroup = container.querySelector(".flow-node");
      expect(nodeGroup).not.toHaveClass("selected");
    });
  });

  describe("accessibility", () => {
    test('has role="button"', () => {
      const { container } = render(FlowNode, {
        props: {
          node: mockNode,
          inputPorts: [],
          outputPorts: [],
        },
      });

      const nodeGroup = container.querySelector(".flow-node");
      expect(nodeGroup?.getAttribute("role")).toBe("button");
    });

    test("has aria-label with node name", () => {
      const { container } = render(FlowNode, {
        props: {
          node: mockNode,
          inputPorts: [],
          outputPorts: [],
        },
      });

      const nodeGroup = container.querySelector(".flow-node");
      expect(nodeGroup?.getAttribute("aria-label")).toContain("UDP Input");
      expect(nodeGroup?.getAttribute("aria-label")).toContain("Click to edit");
    });

    test('has tabindex="0" for keyboard navigation', () => {
      const { container } = render(FlowNode, {
        props: {
          node: mockNode,
          inputPorts: [],
          outputPorts: [],
        },
      });

      const nodeGroup = container.querySelector(".flow-node");
      expect(nodeGroup?.getAttribute("tabindex")).toBe("0");
    });
  });

  describe("different node types", () => {
    test("renders network domain node", () => {
      const networkNode: LayoutNode = {
        ...mockNode,
        type: "network",
        name: "TCP Server",
      };

      const { container } = render(FlowNode, {
        props: {
          node: networkNode,
          inputPorts: [],
          outputPorts: [],
        },
      });

      const label = container.querySelector(".node-label");
      expect(label).toHaveTextContent("TCP Server");

      const typeLabel = container.querySelector(".node-type");
      expect(typeLabel).toHaveTextContent("network");
    });

    test("renders nats domain node", () => {
      const natsNode: LayoutNode = {
        ...mockNode,
        type: "nats",
        name: "NATS Publisher",
      };

      const { container } = render(FlowNode, {
        props: {
          node: natsNode,
          inputPorts: [],
          outputPorts: [],
        },
      });

      const typeLabel = container.querySelector(".node-type");
      expect(typeLabel).toHaveTextContent("nats");
    });
  });

  describe("many ports scenario", () => {
    test("renders node with many input ports", () => {
      const manyInputPorts: ValidatedPort[] = Array.from(
        { length: 10 },
        (_, i) => ({
          name: `input_${i}`,
          direction: "input" as const,
          type: "message.Storable",
          required: i % 2 === 0,
          connection_id: `nats.input.${i}`,
          pattern: "stream",
          description: `Input port ${i}`,
        }),
      );

      const { container } = render(FlowNode, {
        props: {
          node: mockNode,
          inputPorts: manyInputPorts,
          outputPorts: [],
        },
      });

      const inputPorts = container.querySelectorAll(".port-input");
      expect(inputPorts).toHaveLength(10);

      const summary = container.querySelector(".port-summary");
      expect(summary).toHaveTextContent("10 in, 0 out");
    });

    test("ports are correctly spaced vertically", () => {
      const { container } = render(FlowNode, {
        props: {
          node: mockNode,
          inputPorts: mockInputPorts,
          outputPorts: [],
        },
      });

      const ports = container.querySelectorAll(".port-input");

      // First port at y=30
      expect(ports[0].getAttribute("cy")).toBe("30");
      // Second port at y=50 (30 + 20 spacing)
      expect(ports[1].getAttribute("cy")).toBe("50");
    });
  });
});
