<script lang="ts">
	import type { ComponentType, PropertySchema } from '$lib/types/component';
	import ComponentPalette from './ComponentPalette.svelte';

	interface AddComponentModalProps {
		isOpen: boolean;
		componentTypes: ComponentType[];
		onAdd?: (componentType: ComponentType, name: string, config: Record<string, unknown>) => void;
		onClose?: () => void;
	}

	let { isOpen, componentTypes, onAdd, onClose }: AddComponentModalProps = $props();

	// Form state
	let selectedTypeId = $state('');
	let componentName = $state('');
	let configValues = $state<Record<string, unknown>>({});
	let nameWasAutoGenerated = $state(false);

	// Dialog element reference for focus management
	let dialogElement: HTMLDivElement | undefined = $state();

	// Handle component type selection from palette
	function handleSelectType(componentType: ComponentType) {
		selectedTypeId = componentType.id;
	}

	// Go back to type selection
	function handleBackToTypes() {
		selectedTypeId = '';
		componentName = '';
		configValues = {};
		nameWasAutoGenerated = false;
	}

	// Selected component type
	const selectedComponentType = $derived(
		componentTypes.find((ct) => ct.id === selectedTypeId) || null
	);

	// Auto-generate name when component type selected (only if name is empty and not manually cleared)
	$effect(() => {
		if (selectedTypeId && !componentName && !nameWasAutoGenerated) {
			const timestamp = Date.now();
			const sanitizedId = selectedTypeId.replace(/[^a-z0-9-_]/gi, '-');
			componentName = `${sanitizedId}-${timestamp}`;
			nameWasAutoGenerated = true;
		}
	});

	// Initialize config values with defaults when type selected
	$effect(() => {
		if (selectedComponentType?.schema) {
			const defaults: Record<string, unknown> = {};
			Object.entries(selectedComponentType.schema.properties).forEach(([key, schema]) => {
				if (schema.default !== undefined) {
					defaults[key] = schema.default;
				}
			});
			configValues = defaults;
		} else {
			configValues = {};
		}
	});

	// Validation
	const isFormValid = $derived.by(() => {
		if (!selectedTypeId || !componentName.trim()) {
			return false;
		}

		// Check required config fields
		if (selectedComponentType?.schema) {
			const required = selectedComponentType.schema.required || [];
			for (const field of required) {
				const value = configValues[field];
				if (value === undefined || value === null || value === '') {
					return false;
				}

				// Validate number ranges
				const schema = selectedComponentType.schema.properties[field];
				if (schema.type === 'number') {
					const numValue = Number(value);
					if (isNaN(numValue)) {
						return false;
					}
					if (schema.minimum !== undefined && numValue < schema.minimum) {
						return false;
					}
					if (schema.maximum !== undefined && numValue > schema.maximum) {
						return false;
					}
				}
			}
		}

		return true;
	});

	// Get validation error for a field
	function getFieldValidationError(fieldName: string, schema: PropertySchema): string | null {
		const value = configValues[fieldName];

		// Only validate if field has a value
		if (value === undefined || value === null || value === '') {
			return null;
		}

		if (schema.type === 'number') {
			const numValue = Number(value);
			if (isNaN(numValue)) {
				return 'Must be a valid number';
			}
			if (schema.minimum !== undefined && numValue < schema.minimum) {
				return `Value must be at minimum ${schema.minimum}`;
			}
			if (schema.maximum !== undefined && numValue > schema.maximum) {
				return `Value must be at maximum ${schema.maximum}`;
			}
		}

		return null;
	}

	// Handle ESC key to close dialog
	function handleKeydown(event: KeyboardEvent) {
		if (event.key === 'Escape' && isOpen) {
			handleClose();
		}
	}

	// Handle click on overlay background to close dialog
	function handleBackgroundClick(event: MouseEvent) {
		if (event.target === event.currentTarget) {
			handleClose();
		}
	}

	// Handle form submission
	function handleAdd() {
		if (!isFormValid || !selectedComponentType) {
			return;
		}

		onAdd?.(selectedComponentType, componentName, configValues);

		// Reset form
		selectedTypeId = '';
		componentName = '';
		configValues = {};
		nameWasAutoGenerated = false;
	}

	// Handle close
	function handleClose() {
		// Reset form state
		selectedTypeId = '';
		componentName = '';
		configValues = {};
		nameWasAutoGenerated = false;
		onClose?.();
	}

	// Focus management - focus first input when dialog opens
	$effect(() => {
		if (isOpen && dialogElement) {
			const focusable = dialogElement.querySelector<HTMLSelectElement>('select');
			focusable?.focus();
		}
	});
</script>

<svelte:window onkeydown={handleKeydown} />

{#if isOpen}
	<div
		bind:this={dialogElement}
		class="dialog-overlay"
		role="dialog"
		aria-modal="true"
		aria-labelledby="dialog-title"
		tabindex="-1"
		onclick={handleBackgroundClick}
		onkeydown={(e) => e.key === 'Escape' && handleClose()}
	>
		<!-- svelte-ignore a11y_no_static_element_interactions a11y_click_events_have_key_events -->
		<div class="dialog-content" onclick={(e) => e.stopPropagation()}>
			<header class="dialog-header">
				<h2 id="dialog-title">Add Component</h2>
				<button class="close-button" onclick={handleClose} aria-label="Close dialog">×</button>
			</header>

			<div class="dialog-body">
				{#if !selectedTypeId}
					<!-- Step 1: Pick component type from palette -->
					<div class="palette-container">
						<ComponentPalette
							onAddComponent={handleSelectType}
						/>
					</div>
				{:else}
					<!-- Step 2: Configure the selected component -->
					<form onsubmit={(e) => e.preventDefault()}>
						<!-- Back button to change type -->
						<button type="button" class="back-button" onclick={handleBackToTypes}>
							← Change component type
						</button>

						<!-- Selected type display -->
						<div class="selected-type">
							<span class="type-label">Selected:</span>
							<span class="type-name">{selectedComponentType?.name}</span>
						</div>

						<!-- Component Name -->
						<div class="form-group">
							<label for="name">Component Name</label>
							<input
								id="name"
								name="name"
								type="text"
								bind:value={componentName}
								required
								aria-required="true"
								placeholder="Enter component name"
							/>
						</div>

						<!-- Config Fields (dynamic based on selected type) -->
						{#if selectedComponentType?.schema}
							<div class="config-section">
								<h3>Configuration</h3>
								{#each Object.entries(selectedComponentType.schema.properties) as [fieldName, schema] (fieldName)}
									{@const isRequired = selectedComponentType.schema.required?.includes(
										fieldName
									)}
									{@const validationError = getFieldValidationError(fieldName, schema)}

									<div class="form-group">
										<label for="config.{fieldName}">
											{fieldName}
											{#if isRequired}
												<span class="required">*</span>
											{/if}
										</label>
										{#if schema.description}
											<p class="field-description">{schema.description}</p>
										{/if}

										{#if schema.type === 'string'}
											<input
												id="config.{fieldName}"
												name="config.{fieldName}"
												type="text"
												bind:value={configValues[fieldName]}
												required={isRequired}
												aria-required={isRequired}
												aria-invalid={validationError !== null}
											/>
										{:else if schema.type === 'int' || schema.type === 'integer' || schema.type === 'number'}
											<input
												id="config.{fieldName}"
												name="config.{fieldName}"
												type="number"
												bind:value={configValues[fieldName]}
												required={isRequired}
												aria-required={isRequired}
												aria-invalid={validationError !== null}
												min={schema.minimum}
												max={schema.maximum}
											/>
										{:else if schema.type === 'bool' || schema.type === 'boolean'}
											<input
												id="config.{fieldName}"
												name="config.{fieldName}"
												type="checkbox"
												bind:checked={configValues[fieldName] as boolean}
											/>
										{:else if schema.type === 'enum' && schema.enum}
											<select
												id="config.{fieldName}"
												name="config.{fieldName}"
												bind:value={configValues[fieldName]}
												required={isRequired}
												aria-required={isRequired}
											>
												<option value="">Select...</option>
												{#each schema.enum as option}
													<option value={option}>{option}</option>
												{/each}
											</select>
										{:else}
											<!-- object, array, ports - JSON editor -->
											<textarea
												id="config.{fieldName}"
												name="config.{fieldName}"
												class="json-editor"
												value={JSON.stringify(configValues[fieldName] ?? {}, null, 2)}
												onchange={(e) => {
													try {
														configValues[fieldName] = JSON.parse(e.currentTarget.value);
													} catch {
														// Invalid JSON - keep current value
													}
												}}
											></textarea>
										{/if}

										{#if validationError}
											<div class="validation-error">{validationError}</div>
										{/if}
									</div>
								{/each}
							</div>
						{/if}
					</form>
				{/if}
			</div>

			<footer class="dialog-footer">
				<button class="secondary-button" onclick={handleClose}>Cancel</button>
				{#if selectedTypeId}
					<button class="primary-button" onclick={handleAdd} disabled={!isFormValid}>
						Add Component
					</button>
				{/if}
			</footer>
		</div>
	</div>
{/if}

<style>
	.dialog-overlay {
		position: fixed;
		top: 0;
		left: 0;
		right: 0;
		bottom: 0;
		background: rgba(0, 0, 0, 0.5);
		display: flex;
		align-items: center;
		justify-content: center;
		z-index: 1000;
	}

	.dialog-content {
		background: var(--ui-surface-primary);
		border-radius: 8px;
		max-width: 600px;
		width: 90%;
		max-height: 80vh;
		display: flex;
		flex-direction: column;
		box-shadow: 0 4px 20px rgba(0, 0, 0, 0.3);
	}

	.dialog-header {
		display: flex;
		justify-content: space-between;
		align-items: center;
		padding: 1.5rem;
		border-bottom: 1px solid var(--ui-border-subtle);
	}

	.dialog-header h2 {
		margin: 0;
		font-size: 1.5rem;
		color: var(--ui-text-primary);
	}

	.close-button {
		background: none;
		border: none;
		font-size: 2rem;
		cursor: pointer;
		color: var(--ui-text-secondary);
		padding: 0;
		width: 2rem;
		height: 2rem;
		line-height: 1;
	}

	.close-button:hover {
		color: var(--ui-text-primary);
	}

	.dialog-body {
		flex: 1;
		overflow-y: auto;
		padding: 1.5rem;
	}

	.palette-container {
		height: 400px;
		overflow: hidden;
	}

	.palette-container :global(.component-palette) {
		height: 100%;
		border: none;
	}

	.back-button {
		background: none;
		border: none;
		color: var(--ui-interactive-primary);
		cursor: pointer;
		padding: 0;
		font-size: 0.875rem;
		margin-bottom: 1rem;
	}

	.back-button:hover {
		text-decoration: underline;
	}

	.selected-type {
		display: flex;
		align-items: center;
		gap: 0.5rem;
		padding: 0.75rem;
		background: var(--ui-surface-secondary);
		border-radius: 4px;
		margin-bottom: 1.5rem;
	}

	.type-label {
		color: var(--ui-text-secondary);
		font-size: 0.875rem;
	}

	.type-name {
		font-weight: 600;
		color: var(--ui-text-primary);
	}

	.form-group {
		margin-bottom: 1.5rem;
	}

	.form-group label {
		display: block;
		margin-bottom: 0.5rem;
		font-weight: 600;
		color: var(--ui-text-primary);
	}

	.form-group input,
	.form-group select {
		width: 100%;
		padding: 0.5rem;
		border: 1px solid var(--ui-border-default);
		border-radius: 4px;
		font-size: 1rem;
		background: var(--ui-surface-primary);
		color: var(--ui-text-primary);
	}

	.form-group input[type='checkbox'] {
		width: auto;
	}

	.form-group input:focus,
	.form-group select:focus {
		outline: 2px solid var(--ui-focus-ring);
		outline-offset: 1px;
		border-color: var(--ui-interactive-primary);
	}

	.form-group input[aria-invalid='true'] {
		border-color: var(--status-error);
	}

	.json-editor {
		width: 100%;
		min-height: 100px;
		padding: 0.5rem;
		border: 1px solid var(--ui-border-default);
		border-radius: 4px;
		font-family: 'SF Mono', Monaco, 'Cascadia Code', monospace;
		font-size: 0.8rem;
		background: var(--ui-surface-primary);
		color: var(--ui-text-primary);
		resize: vertical;
		white-space: pre;
		tab-size: 2;
	}

	.json-editor:focus {
		outline: 2px solid var(--ui-focus-ring);
		outline-offset: 1px;
		border-color: var(--ui-interactive-primary);
	}

	.field-description {
		font-size: 0.875rem;
		color: var(--ui-text-secondary);
		margin: 0.25rem 0 0.5rem 0;
	}

	.required {
		color: var(--status-error);
	}

	.validation-error {
		color: var(--status-error);
		font-size: 0.875rem;
		margin-top: 0.25rem;
	}

	.config-section {
		margin-top: 2rem;
		padding-top: 1.5rem;
		border-top: 1px solid var(--ui-border-subtle);
	}

	.config-section h3 {
		margin: 0 0 1rem 0;
		font-size: 1.125rem;
		color: var(--ui-text-primary);
	}

	.dialog-footer {
		padding: 1.5rem;
		border-top: 1px solid var(--ui-border-subtle);
		display: flex;
		justify-content: flex-end;
		gap: 1rem;
	}

	.primary-button,
	.secondary-button {
		padding: 0.75rem 1.5rem;
		border: none;
		border-radius: 4px;
		cursor: pointer;
		font-size: 1rem;
		transition: all 0.2s;
	}

	.primary-button {
		background: var(--ui-interactive-primary);
		color: var(--ui-text-on-primary);
	}

	.primary-button:hover:not(:disabled) {
		background: var(--ui-interactive-primary-hover);
	}

	.primary-button:disabled {
		opacity: 0.5;
		cursor: not-allowed;
	}

	.secondary-button {
		background: var(--ui-surface-secondary);
		color: var(--ui-text-primary);
		border: 1px solid var(--ui-border-default);
	}

	.secondary-button:hover {
		background: var(--ui-surface-tertiary);
	}
</style>
