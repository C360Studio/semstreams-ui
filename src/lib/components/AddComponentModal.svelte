<script lang="ts">
	import type { ComponentType, PropertySchema } from '$lib/types/component';

	interface AddComponentModalProps {
		isOpen: boolean;
		componentTypes: ComponentType[];
		onAdd?: (componentType: ComponentType, name: string, config: Record<string, unknown>) => void;
		onClose?: () => void;
	}

	let { isOpen, componentTypes, onAdd, onClose }: AddComponentModalProps = $props();

	// Form state
	let selectedTypeId = $state('');
	let componentName = $state('');
	let configValues = $state<Record<string, unknown>>({});
	let nameWasAutoGenerated = $state(false);

	// Dialog element reference for focus management
	let dialogElement: HTMLDivElement | undefined = $state();

	// Selected component type
	const selectedComponentType = $derived(
		componentTypes.find((ct) => ct.id === selectedTypeId) || null
	);

	// Auto-generate name when component type selected (only if name is empty and not manually cleared)
	$effect(() => {
		if (selectedTypeId && !componentName && !nameWasAutoGenerated) {
			const timestamp = Date.now();
			const sanitizedId = selectedTypeId.replace(/[^a-z0-9-_]/gi, '-');
			componentName = `${sanitizedId}-${timestamp}`;
			nameWasAutoGenerated = true;
		}
	});

	// Initialize config values with defaults when type selected
	$effect(() => {
		if (selectedComponentType?.configSchema) {
			const defaults: Record<string, unknown> = {};
			Object.entries(selectedComponentType.configSchema.properties).forEach(([key, schema]) => {
				if (schema.default !== undefined) {
					defaults[key] = schema.default;
				}
			});
			configValues = defaults;
		} else {
			configValues = {};
		}
	});

	// Validation
	const isFormValid = $derived.by(() => {
		if (!selectedTypeId || !componentName.trim()) {
			return false;
		}

		// Check required config fields
		if (selectedComponentType?.configSchema) {
			const required = selectedComponentType.configSchema.required || [];
			for (const field of required) {
				const value = configValues[field];
				if (value === undefined || value === null || value === '') {
					return false;
				}

				// Validate number ranges
				const schema = selectedComponentType.configSchema.properties[field];
				if (schema.type === 'number') {
					const numValue = Number(value);
					if (isNaN(numValue)) {
						return false;
					}
					if (schema.minimum !== undefined && numValue < schema.minimum) {
						return false;
					}
					if (schema.maximum !== undefined && numValue > schema.maximum) {
						return false;
					}
				}
			}
		}

		return true;
	});

	// Get validation error for a field
	function getFieldValidationError(fieldName: string, schema: PropertySchema): string | null {
		const value = configValues[fieldName];

		// Only validate if field has a value
		if (value === undefined || value === null || value === '') {
			return null;
		}

		if (schema.type === 'number') {
			const numValue = Number(value);
			if (isNaN(numValue)) {
				return 'Must be a valid number';
			}
			if (schema.minimum !== undefined && numValue < schema.minimum) {
				return `Value must be at minimum ${schema.minimum}`;
			}
			if (schema.maximum !== undefined && numValue > schema.maximum) {
				return `Value must be at maximum ${schema.maximum}`;
			}
		}

		return null;
	}

	// Handle ESC key to close dialog
	function handleKeydown(event: KeyboardEvent) {
		if (event.key === 'Escape' && isOpen) {
			handleClose();
		}
	}

	// Handle click on overlay background to close dialog
	function handleBackgroundClick(event: MouseEvent) {
		if (event.target === event.currentTarget) {
			handleClose();
		}
	}

	// Handle form submission
	function handleAdd() {
		if (!isFormValid || !selectedComponentType) {
			return;
		}

		onAdd?.(selectedComponentType, componentName, configValues);

		// Reset form
		selectedTypeId = '';
		componentName = '';
		configValues = {};
		nameWasAutoGenerated = false;
	}

	// Handle close
	function handleClose() {
		onClose?.();
	}

	// Focus management - focus first input when dialog opens
	$effect(() => {
		if (isOpen && dialogElement) {
			const focusable = dialogElement.querySelector<HTMLSelectElement>('select');
			focusable?.focus();
		}
	});
</script>

<svelte:window onkeydown={handleKeydown} />

{#if isOpen}
	<div
		bind:this={dialogElement}
		class="dialog-overlay"
		role="dialog"
		aria-modal="true"
		aria-labelledby="dialog-title"
		tabindex="-1"
		onclick={handleBackgroundClick}
		onkeydown={(e) => e.key === 'Escape' && handleClose()}
	>
		<!-- svelte-ignore a11y_no_static_element_interactions a11y_click_events_have_key_events -->
		<div class="dialog-content" onclick={(e) => e.stopPropagation()}>
			<header class="dialog-header">
				<h2 id="dialog-title">Add Component</h2>
				<button class="close-button" onclick={handleClose} aria-label="Close dialog">Ã—</button>
			</header>

			<div class="dialog-body">
				<form onsubmit={(e) => e.preventDefault()}>
					<!-- Component Type Selection -->
					<div class="form-group">
						<label for="componentType">Component Type</label>
						<select
							id="componentType"
							name="componentType"
							bind:value={selectedTypeId}
							required
						>
							<option value="">Select a component type</option>
							{#each componentTypes as componentType (componentType.id)}
								<option value={componentType.id}>{componentType.name}</option>
							{/each}
						</select>
					</div>

					<!-- Component Name -->
					<div class="form-group">
						<label for="name">Component Name</label>
						<input
							id="name"
							name="name"
							type="text"
							bind:value={componentName}
							required
							aria-required="true"
							placeholder="Enter component name"
						/>
					</div>

					<!-- Config Fields (dynamic based on selected type) -->
					{#if selectedComponentType?.configSchema}
						<div class="config-section">
							<h3>Configuration</h3>
							{#each Object.entries(selectedComponentType.configSchema.properties) as [fieldName, schema] (fieldName)}
								{@const isRequired = selectedComponentType.configSchema.required?.includes(
									fieldName
								)}
								{@const validationError = getFieldValidationError(fieldName, schema)}

								<div class="form-group">
									<label for="config.{fieldName}">
										{fieldName}
										{#if isRequired}
											<span class="required">*</span>
										{/if}
									</label>
									{#if schema.description}
										<p class="field-description">{schema.description}</p>
									{/if}

									{#if schema.type === 'string'}
										<input
											id="config.{fieldName}"
											name="config.{fieldName}"
											type="text"
											bind:value={configValues[fieldName]}
											required={isRequired}
											aria-required={isRequired}
											aria-invalid={validationError !== null}
										/>
									{:else if schema.type === 'number'}
										<input
											id="config.{fieldName}"
											name="config.{fieldName}"
											type="number"
											bind:value={configValues[fieldName]}
											required={isRequired}
											aria-required={isRequired}
											aria-invalid={validationError !== null}
											min={schema.minimum}
											max={schema.maximum}
										/>
									{:else if schema.type === 'boolean'}
										<input
											id="config.{fieldName}"
											name="config.{fieldName}"
											type="checkbox"
											bind:checked={configValues[fieldName] as boolean}
										/>
									{/if}

									{#if validationError}
										<div class="validation-error">{validationError}</div>
									{/if}
								</div>
							{/each}
						</div>
					{/if}
				</form>
			</div>

			<footer class="dialog-footer">
				<button class="secondary-button" onclick={handleClose}>Cancel</button>
				<button class="primary-button" onclick={handleAdd} disabled={!isFormValid}>
					Add Component
				</button>
			</footer>
		</div>
	</div>
{/if}

<style>
	.dialog-overlay {
		position: fixed;
		top: 0;
		left: 0;
		right: 0;
		bottom: 0;
		background: rgba(0, 0, 0, 0.5);
		display: flex;
		align-items: center;
		justify-content: center;
		z-index: 1000;
	}

	.dialog-content {
		background: var(--pico-background-color);
		border-radius: 8px;
		max-width: 600px;
		width: 90%;
		max-height: 80vh;
		display: flex;
		flex-direction: column;
		box-shadow: 0 4px 20px rgba(0, 0, 0, 0.3);
	}

	.dialog-header {
		display: flex;
		justify-content: space-between;
		align-items: center;
		padding: 1.5rem;
		border-bottom: 1px solid var(--pico-muted-border-color);
	}

	.dialog-header h2 {
		margin: 0;
		font-size: 1.5rem;
		color: var(--pico-color);
	}

	.close-button {
		background: none;
		border: none;
		font-size: 2rem;
		cursor: pointer;
		color: var(--pico-muted-color);
		padding: 0;
		width: 2rem;
		height: 2rem;
		line-height: 1;
	}

	.close-button:hover {
		color: var(--pico-color);
	}

	.dialog-body {
		flex: 1;
		overflow-y: auto;
		padding: 1.5rem;
	}

	.form-group {
		margin-bottom: 1.5rem;
	}

	.form-group label {
		display: block;
		margin-bottom: 0.5rem;
		font-weight: 600;
		color: var(--ui-text-primary);
	}

	.form-group input,
	.form-group select {
		width: 100%;
		padding: 0.5rem;
		border: 1px solid var(--ui-border-default);
		border-radius: 4px;
		font-size: 1rem;
		background: var(--pico-background-color);
		color: var(--pico-color);
	}

	.form-group input[type='checkbox'] {
		width: auto;
	}

	.form-group input:focus,
	.form-group select:focus {
		outline: 2px solid var(--ui-focus-ring);
		outline-offset: 1px;
		border-color: var(--pico-primary);
	}

	.form-group input[aria-invalid='true'] {
		border-color: var(--status-error);
	}

	.field-description {
		font-size: 0.875rem;
		color: var(--ui-text-secondary);
		margin: 0.25rem 0 0.5rem 0;
	}

	.required {
		color: var(--status-error);
	}

	.validation-error {
		color: var(--status-error);
		font-size: 0.875rem;
		margin-top: 0.25rem;
	}

	.config-section {
		margin-top: 2rem;
		padding-top: 1.5rem;
		border-top: 1px solid var(--ui-border-subtle);
	}

	.config-section h3 {
		margin: 0 0 1rem 0;
		font-size: 1.125rem;
		color: var(--ui-text-primary);
	}

	.dialog-footer {
		padding: 1.5rem;
		border-top: 1px solid var(--pico-muted-border-color);
		display: flex;
		justify-content: flex-end;
		gap: 1rem;
	}

	.primary-button,
	.secondary-button {
		padding: 0.75rem 1.5rem;
		border: none;
		border-radius: 4px;
		cursor: pointer;
		font-size: 1rem;
		transition: all 0.2s;
	}

	.primary-button {
		background: var(--pico-primary);
		color: var(--pico-primary-inverse);
	}

	.primary-button:hover:not(:disabled) {
		background: var(--pico-primary-hover);
	}

	.primary-button:disabled {
		opacity: 0.5;
		cursor: not-allowed;
	}

	.secondary-button {
		background: var(--ui-surface-secondary);
		color: var(--ui-text-primary);
		border: 1px solid var(--ui-border-default);
	}

	.secondary-button:hover {
		background: var(--ui-surface-tertiary);
	}
</style>
