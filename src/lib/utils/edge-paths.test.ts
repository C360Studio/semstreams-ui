// Code generated by Tester Agent. DO NOT EDIT.
// Task: Sprint 1 - D3 Canvas utility tests for Bezier curve edge path calculation
// Builder must make these tests pass without modification.

import { describe, test, expect } from "vitest";
import {
  generateBezierPath,
  edgeToPath,
  getPathStyle,
  getBezierMidpoint,
  isPointNearEdge,
  PATH_STYLES,
} from "./edge-paths";
import type { LayoutEdge } from "./d3-layout";

describe("generateBezierPath", () => {
  describe("basic path generation", () => {
    test("generates SVG path string for horizontal edge", () => {
      const path = generateBezierPath(0, 100, 200, 100);

      expect(path).toMatch(/^M \d+ \d+ C/); // Starts with M (move) and C (cubic bezier)
      expect(path).toContain("M 0 100"); // Starts at source
      expect(path).toContain("200 100"); // Ends at target
    });

    test("generates SVG path string for diagonal edge", () => {
      const path = generateBezierPath(0, 0, 200, 100);

      expect(path).toMatch(/^M \d+ \d+ C/);
      expect(path).toContain("M 0 0"); // Source
      expect(path).toContain("200 100"); // Target
    });

    test("generates path for edge going upward", () => {
      const path = generateBezierPath(0, 100, 200, 0);

      expect(path).toMatch(/^M \d+ \d+ C/);
      expect(path).toContain("M 0 100");
      expect(path).toContain("200 0");
    });

    test("generates path for edge going downward", () => {
      const path = generateBezierPath(0, 0, 200, 100);

      expect(path).toMatch(/^M \d+ \d+ C/);
      expect(path).toContain("M 0 0");
      expect(path).toContain("200 100");
    });
  });

  describe("control point calculation", () => {
    test("creates smooth curve for medium distance", () => {
      const path = generateBezierPath(0, 50, 200, 50);

      // Extract control points from path string
      // Path format: M x1 y1 C cx1 cy1, cx2 cy2, x2 y2
      const match = path.match(
        /M (\d+) (\d+) C ([\d.]+) ([\d.]+), ([\d.]+) ([\d.]+), (\d+) (\d+)/,
      );
      expect(match).not.toBeNull();

      if (match) {
        const [, , , c1x, c1y, c2x, c2y] = match;
        // Control points should extend horizontally from source and target
        expect(parseFloat(c1x)).toBeGreaterThan(0); // Extends right from source
        expect(parseFloat(c1y)).toBe(50); // Same Y as source
        expect(parseFloat(c2x)).toBeLessThan(200); // Extends left from target
        expect(parseFloat(c2y)).toBe(50); // Same Y as target
      }
    });

    test("limits control offset for very long edges", () => {
      const path = generateBezierPath(0, 50, 1000, 50);

      // Control offset should be capped at 100 (per implementation)
      const match = path.match(
        /M (\d+) (\d+) C ([\d.]+) ([\d.]+), ([\d.]+) ([\d.]+), (\d+) (\d+)/,
      );
      expect(match).not.toBeNull();

      if (match) {
        const [, , , c1x] = match;
        // Control point should be at most 100 away from source
        expect(parseFloat(c1x)).toBeLessThanOrEqual(100);
      }
    });

    test("handles short edges correctly", () => {
      const path = generateBezierPath(0, 50, 50, 50);

      expect(path).toContain("M 0 50");
      expect(path).toContain("50 50");
      // Should still generate valid bezier curve
      expect(path).toMatch(/C [\d.]+ [\d.]+, [\d.]+ [\d.]+,/);
    });
  });

  describe("edge cases", () => {
    test("handles zero-length edge (same source and target)", () => {
      const path = generateBezierPath(100, 100, 100, 100);

      expect(path).toContain("M 100 100");
      expect(path).toContain("100 100");
    });

    test("handles negative coordinates", () => {
      const path = generateBezierPath(-50, -50, 50, 50);

      expect(path).toContain("M -50 -50");
      expect(path).toContain("50 50");
    });

    test("handles very large coordinates", () => {
      const path = generateBezierPath(0, 0, 10000, 10000);

      expect(path).toContain("M 0 0");
      expect(path).toContain("10000 10000");
    });
  });
});

describe("edgeToPath", () => {
  test("converts layout edge to SVG path string", () => {
    const edge: LayoutEdge = {
      id: "edge-1",
      sourceNodeId: "a",
      sourcePort: "out",
      targetNodeId: "b",
      targetPort: "in",
      sourceX: 250,
      sourceY: 90,
      targetX: 350,
      targetY: 90,
      original: {
        id: "edge-1",
        source_node_id: "a",
        source_port: "out",
        target_node_id: "b",
        target_port: "in",
      },
    };

    const path = edgeToPath(edge);

    expect(path).toContain("M 250 90");
    expect(path).toContain("350 90");
    expect(path).toMatch(/^M \d+ \d+ C/);
  });

  test("handles edge with different Y coordinates", () => {
    const edge: LayoutEdge = {
      id: "edge-2",
      sourceNodeId: "a",
      sourcePort: "out",
      targetNodeId: "c",
      targetPort: "in",
      sourceX: 250,
      sourceY: 90,
      targetX: 350,
      targetY: 230,
      original: {
        id: "edge-2",
        source_node_id: "a",
        source_port: "out",
        target_node_id: "c",
        target_port: "in",
      },
    };

    const path = edgeToPath(edge);

    expect(path).toContain("M 250 90");
    expect(path).toContain("350 230");
  });
});

describe("getPathStyle", () => {
  describe("validation state styling", () => {
    test("returns error style for edge with error validation state", () => {
      const edge: LayoutEdge = {
        id: "edge-1",
        sourceNodeId: "a",
        sourcePort: "out",
        targetNodeId: "b",
        targetPort: "in",
        sourceX: 250,
        sourceY: 90,
        targetX: 350,
        targetY: 90,
        original: {
          id: "edge-1",
          source_node_id: "a",
          source_port: "out",
          target_node_id: "b",
          target_port: "in",
          validationState: "error",
        },
      };

      const style = getPathStyle(edge);

      expect(style).toEqual(PATH_STYLES.error);
      expect(style.stroke).toBe(PATH_STYLES.error.stroke);
      expect(style.strokeDasharray).toBe("5,5"); // Dashed for error
    });

    test("returns warning style for edge with warning validation state", () => {
      const edge: LayoutEdge = {
        id: "edge-1",
        sourceNodeId: "a",
        sourcePort: "out",
        targetNodeId: "b",
        targetPort: "in",
        sourceX: 250,
        sourceY: 90,
        targetX: 350,
        targetY: 90,
        original: {
          id: "edge-1",
          source_node_id: "a",
          source_port: "out",
          target_node_id: "b",
          target_port: "in",
          validationState: "warning",
        },
      };

      const style = getPathStyle(edge);

      expect(style).toEqual(PATH_STYLES.warning);
      expect(style.stroke).toBe(PATH_STYLES.warning.stroke);
      expect(style.strokeDasharray).toBe("5,5"); // Dashed for warning
    });

    test("returns valid style for edge without validation errors", () => {
      const edge: LayoutEdge = {
        id: "edge-1",
        sourceNodeId: "a",
        sourcePort: "out",
        targetNodeId: "b",
        targetPort: "in",
        sourceX: 250,
        sourceY: 90,
        targetX: 350,
        targetY: 90,
        original: {
          id: "edge-1",
          source_node_id: "a",
          source_port: "out",
          target_node_id: "b",
          target_port: "in",
        },
      };

      const style = getPathStyle(edge);

      expect(style).toEqual(PATH_STYLES.valid);
      expect(style.strokeDasharray).toBe(""); // Solid line
    });
  });

  describe("auto-discovered edge styling", () => {
    test("returns auto style for auto-discovered edge", () => {
      const edge: LayoutEdge = {
        id: "edge-1",
        sourceNodeId: "a",
        sourcePort: "out",
        targetNodeId: "b",
        targetPort: "in",
        sourceX: 250,
        sourceY: 90,
        targetX: 350,
        targetY: 90,
        original: {
          id: "edge-1",
          source_node_id: "a",
          source_port: "out",
          target_node_id: "b",
          target_port: "in",
          source: "auto",
        },
      };

      const style = getPathStyle(edge);

      expect(style).toEqual(PATH_STYLES.auto);
      expect(style.strokeDasharray).toBe("3,3"); // Dotted for auto
    });

    test("returns valid style for manually created edge", () => {
      const edge: LayoutEdge = {
        id: "edge-1",
        sourceNodeId: "a",
        sourcePort: "out",
        targetNodeId: "b",
        targetPort: "in",
        sourceX: 250,
        sourceY: 90,
        targetX: 350,
        targetY: 90,
        original: {
          id: "edge-1",
          source_node_id: "a",
          source_port: "out",
          target_node_id: "b",
          target_port: "in",
          source: "manual",
        },
      };

      const style = getPathStyle(edge);

      expect(style).toEqual(PATH_STYLES.valid);
    });
  });

  describe("style priority", () => {
    test("prioritizes error state over auto-discovered", () => {
      const edge: LayoutEdge = {
        id: "edge-1",
        sourceNodeId: "a",
        sourcePort: "out",
        targetNodeId: "b",
        targetPort: "in",
        sourceX: 250,
        sourceY: 90,
        targetX: 350,
        targetY: 90,
        original: {
          id: "edge-1",
          source_node_id: "a",
          source_port: "out",
          target_node_id: "b",
          target_port: "in",
          source: "auto",
          validationState: "error",
        },
      };

      const style = getPathStyle(edge);

      expect(style).toEqual(PATH_STYLES.error);
    });

    test("prioritizes warning state over auto-discovered", () => {
      const edge: LayoutEdge = {
        id: "edge-1",
        sourceNodeId: "a",
        sourcePort: "out",
        targetNodeId: "b",
        targetPort: "in",
        sourceX: 250,
        sourceY: 90,
        targetX: 350,
        targetY: 90,
        original: {
          id: "edge-1",
          source_node_id: "a",
          source_port: "out",
          target_node_id: "b",
          target_port: "in",
          source: "auto",
          validationState: "warning",
        },
      };

      const style = getPathStyle(edge);

      expect(style).toEqual(PATH_STYLES.warning);
    });
  });
});

describe("PATH_STYLES constants", () => {
  test("defines valid style", () => {
    expect(PATH_STYLES.valid).toMatchObject({
      stroke: "var(--pico-primary)",
      strokeWidth: 2,
      strokeDasharray: "",
      showArrow: true,
    });
  });

  test("defines error style", () => {
    expect(PATH_STYLES.error).toMatchObject({
      stroke: "var(--pico-del-color, #c62828)",
      strokeWidth: 2,
      strokeDasharray: "5,5",
      showArrow: true,
    });
  });

  test("defines warning style", () => {
    expect(PATH_STYLES.warning).toMatchObject({
      stroke: "var(--pico-mark-background-color, #ff9800)",
      strokeWidth: 2,
      strokeDasharray: "5,5",
      showArrow: true,
    });
  });

  test("defines auto style", () => {
    expect(PATH_STYLES.auto).toMatchObject({
      stroke: "var(--pico-secondary)",
      strokeWidth: 2,
      strokeDasharray: "3,3",
      showArrow: true,
    });
  });
});

describe("getBezierMidpoint", () => {
  test("calculates approximate midpoint for horizontal edge", () => {
    const midpoint = getBezierMidpoint(0, 100, 200, 100);

    expect(midpoint).toEqual({ x: 100, y: 100 });
  });

  test("calculates approximate midpoint for diagonal edge", () => {
    const midpoint = getBezierMidpoint(0, 0, 200, 100);

    expect(midpoint).toEqual({ x: 100, y: 50 });
  });

  test("calculates midpoint for edge going upward", () => {
    const midpoint = getBezierMidpoint(0, 100, 200, 0);

    expect(midpoint).toEqual({ x: 100, y: 50 });
  });

  test("calculates midpoint for same source and target", () => {
    const midpoint = getBezierMidpoint(100, 100, 100, 100);

    expect(midpoint).toEqual({ x: 100, y: 100 });
  });

  test("calculates midpoint with negative coordinates", () => {
    const midpoint = getBezierMidpoint(-100, -50, 100, 50);

    expect(midpoint).toEqual({ x: 0, y: 0 });
  });
});

describe("isPointNearEdge", () => {
  const createHorizontalEdge = (): LayoutEdge => ({
    id: "edge-1",
    sourceNodeId: "a",
    sourcePort: "out",
    targetNodeId: "b",
    targetPort: "in",
    sourceX: 0,
    sourceY: 100,
    targetX: 200,
    targetY: 100,
    original: {
      id: "edge-1",
      source_node_id: "a",
      source_port: "out",
      target_node_id: "b",
      target_port: "in",
    },
  });

  const createDiagonalEdge = (): LayoutEdge => ({
    id: "edge-2",
    sourceNodeId: "a",
    sourcePort: "out",
    targetNodeId: "b",
    targetPort: "in",
    sourceX: 0,
    sourceY: 0,
    targetX: 200,
    targetY: 200,
    original: {
      id: "edge-2",
      source_node_id: "a",
      source_port: "out",
      target_node_id: "b",
      target_port: "in",
    },
  });

  describe("point proximity detection", () => {
    test("returns true for point near horizontal edge", () => {
      const edge = createHorizontalEdge();

      const isNear = isPointNearEdge(100, 100, edge, 10);

      expect(isNear).toBe(true);
    });

    test("returns false for point far from horizontal edge", () => {
      const edge = createHorizontalEdge();

      const isNear = isPointNearEdge(100, 150, edge, 10);

      expect(isNear).toBe(false);
    });

    test("returns true for point near diagonal edge", () => {
      const edge = createDiagonalEdge();

      const isNear = isPointNearEdge(100, 100, edge, 10);

      expect(isNear).toBe(true);
    });

    test("returns false for point far from diagonal edge", () => {
      const edge = createDiagonalEdge();

      const isNear = isPointNearEdge(50, 150, edge, 10);

      expect(isNear).toBe(false);
    });
  });

  describe("threshold variations", () => {
    test("uses default threshold of 10 when not specified", () => {
      const edge = createHorizontalEdge();

      const isNear = isPointNearEdge(100, 109, edge);

      expect(isNear).toBe(true);
    });

    test("respects custom threshold", () => {
      const edge = createHorizontalEdge();

      const isNearWith5 = isPointNearEdge(100, 106, edge, 5);
      const isNearWith20 = isPointNearEdge(100, 106, edge, 20);

      expect(isNearWith5).toBe(false);
      expect(isNearWith20).toBe(true);
    });

    test("detects points exactly at threshold distance", () => {
      const edge = createHorizontalEdge();

      const isNear = isPointNearEdge(100, 110, edge, 10);

      expect(isNear).toBe(true);
    });
  });

  describe("edge cases", () => {
    test("returns true for point at edge start", () => {
      const edge = createHorizontalEdge();

      const isNear = isPointNearEdge(0, 100, edge, 10);

      expect(isNear).toBe(true);
    });

    test("returns true for point at edge end", () => {
      const edge = createHorizontalEdge();

      const isNear = isPointNearEdge(200, 100, edge, 10);

      expect(isNear).toBe(true);
    });

    test("handles point with negative coordinates", () => {
      const edge = createHorizontalEdge();

      // Point at -10, 100 is within threshold of edge start at 0, 100
      const isNear = isPointNearEdge(-10, 100, edge, 10);
      expect(isNear).toBe(true);

      // Point far from edge should be false
      const isFar = isPointNearEdge(-50, 100, edge, 10);
      expect(isFar).toBe(false);
    });

    test("handles zero threshold", () => {
      const edge = createHorizontalEdge();

      const isNear = isPointNearEdge(100, 100, edge, 0);

      // Should only match exact points on the curve
      expect(typeof isNear).toBe("boolean");
    });
  });

  describe("curved path detection", () => {
    test("detects points along the Bezier curve path", () => {
      const edge = createDiagonalEdge();

      // Test multiple points along the expected curve
      const nearStart = isPointNearEdge(10, 10, edge, 15);
      const nearMiddle = isPointNearEdge(100, 100, edge, 15);
      const nearEnd = isPointNearEdge(190, 190, edge, 15);

      expect(nearStart).toBe(true);
      expect(nearMiddle).toBe(true);
      expect(nearEnd).toBe(true);
    });

    test("rejects points not on the curved path", () => {
      const edge = createDiagonalEdge();

      // Point that would be on a straight line but not on the Bezier curve
      const offCurve = isPointNearEdge(50, 200, edge, 10);

      expect(offCurve).toBe(false);
    });
  });

  describe("performance with sampling", () => {
    test("samples curve at multiple points for accuracy", () => {
      const edge = createHorizontalEdge();

      // Should detect point near middle of curve
      const result = isPointNearEdge(100, 105, edge, 10);

      expect(typeof result).toBe("boolean");
      // Function should complete without hanging
    });
  });
});
