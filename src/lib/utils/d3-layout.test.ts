// Code generated by Tester Agent. DO NOT EDIT.
// Task: Sprint 1 - D3 Canvas utility tests for flow visualization layout
// Builder must make these tests pass without modification.

import { describe, test, expect, vi } from "vitest";
import {
  layoutNodes,
  layoutEdges,
  calculateCanvasBounds,
  createZoomBehavior,
  fitToContent,
  type LayoutNode,
  type LayoutConfig,
} from "./d3-layout";
import type { FlowNode, FlowConnection } from "$lib/types/flow";

describe("layoutNodes", () => {
  describe("empty and single node scenarios", () => {
    test("returns empty array for empty flow", () => {
      const nodes: FlowNode[] = [];
      const connections: FlowConnection[] = [];

      const result = layoutNodes(nodes, connections);

      expect(result).toEqual([]);
    });

    test("positions single node at origin with padding", () => {
      const nodes: FlowNode[] = [
        {
          id: "node-1",
          component: "udp-input", type: "input",
          name: "UDP Input",
          position: { x: 0, y: 0 },
          config: { port: 5000 },
        },
      ];
      const connections: FlowConnection[] = [];

      const result = layoutNodes(nodes, connections);

      expect(result).toHaveLength(1);
      expect(result[0]).toMatchObject({
        id: "node-1",
        component: "udp-input", type: "input",
        name: "UDP Input",
        x: 50, // DEFAULT_CONFIG.padding
        y: 50,
        width: 200,
        height: 80,
      });
      expect(result[0].original).toBe(nodes[0]);
    });
  });

  describe("linear flow scenarios", () => {
    test("positions linear flow (A → B → C) in columns", () => {
      const nodes: FlowNode[] = [
        {
          id: "a",
          component: "input", type: "input",
          name: "A",
          position: { x: 0, y: 0 },
          config: {},
        },
        {
          id: "b",
          component: "transform", type: "processor",
          name: "B",
          position: { x: 0, y: 0 },
          config: {},
        },
        {
          id: "c",
          component: "output", type: "output",
          name: "C",
          position: { x: 0, y: 0 },
          config: {},
        },
      ];
      const connections: FlowConnection[] = [
        {
          id: "conn-1",
          source_node_id: "a",
          source_port: "out",
          target_node_id: "b",
          target_port: "in",
        },
        {
          id: "conn-2",
          source_node_id: "b",
          source_port: "out",
          target_node_id: "c",
          target_port: "in",
        },
      ];

      const result = layoutNodes(nodes, connections);

      expect(result).toHaveLength(3);

      // Node A should be in column 0
      const nodeA = result.find((n) => n.id === "a");
      expect(nodeA?.x).toBe(50); // padding

      // Node B should be in column 1
      const nodeB = result.find((n) => n.id === "b");
      expect(nodeB?.x).toBe(50 + 200 + 100); // padding + width + horizontalSpacing

      // Node C should be in column 2
      const nodeC = result.find((n) => n.id === "c");
      expect(nodeC?.x).toBe(50 + 2 * (200 + 100));
    });
  });

  describe("branching flow scenarios", () => {
    test("positions branching flow (A → B, A → C) correctly", () => {
      const nodes: FlowNode[] = [
        {
          id: "a",
          component: "input", type: "input",
          name: "A",
          position: { x: 0, y: 0 },
          config: {},
        },
        {
          id: "b",
          component: "output-1", type: "output",
          name: "B",
          position: { x: 0, y: 0 },
          config: {},
        },
        {
          id: "c",
          component: "output-2", type: "output",
          name: "C",
          position: { x: 0, y: 0 },
          config: {},
        },
      ];
      const connections: FlowConnection[] = [
        {
          id: "conn-1",
          source_node_id: "a",
          source_port: "out",
          target_node_id: "b",
          target_port: "in",
        },
        {
          id: "conn-2",
          source_node_id: "a",
          source_port: "out",
          target_node_id: "c",
          target_port: "in",
        },
      ];

      const result = layoutNodes(nodes, connections);

      expect(result).toHaveLength(3);

      // Node A should be in column 0
      const nodeA = result.find((n) => n.id === "a");
      expect(nodeA?.x).toBe(50);

      // Nodes B and C should both be in column 1
      const nodeB = result.find((n) => n.id === "b");
      const nodeC = result.find((n) => n.id === "c");
      expect(nodeB?.x).toBe(350); // Same column
      expect(nodeC?.x).toBe(350); // Same column

      // B and C should be stacked vertically
      expect(nodeB?.y).not.toBe(nodeC?.y);
      const yDifference = Math.abs((nodeB?.y || 0) - (nodeC?.y || 0));
      expect(yDifference).toBe(80 + 60); // height + verticalSpacing
    });

    test("positions diamond pattern (A → B, A → C, B → D, C → D) correctly", () => {
      const nodes: FlowNode[] = [
        {
          id: "a",
          component: "input", type: "input",
          name: "A",
          position: { x: 0, y: 0 },
          config: {},
        },
        {
          id: "b",
          component: "mid-1", type: "processor",
          name: "B",
          position: { x: 0, y: 0 },
          config: {},
        },
        {
          id: "c",
          component: "mid-2", type: "processor",
          name: "C",
          position: { x: 0, y: 0 },
          config: {},
        },
        {
          id: "d",
          component: "output", type: "output",
          name: "D",
          position: { x: 0, y: 0 },
          config: {},
        },
      ];
      const connections: FlowConnection[] = [
        {
          id: "1",
          source_node_id: "a",
          source_port: "out",
          target_node_id: "b",
          target_port: "in",
        },
        {
          id: "2",
          source_node_id: "a",
          source_port: "out",
          target_node_id: "c",
          target_port: "in",
        },
        {
          id: "3",
          source_node_id: "b",
          source_port: "out",
          target_node_id: "d",
          target_port: "in",
        },
        {
          id: "4",
          source_node_id: "c",
          source_port: "out",
          target_node_id: "d",
          target_port: "in",
        },
      ];

      const result = layoutNodes(nodes, connections);

      expect(result).toHaveLength(4);

      // Check column assignments
      const nodeA = result.find((n) => n.id === "a");
      const nodeB = result.find((n) => n.id === "b");
      const nodeC = result.find((n) => n.id === "c");
      const nodeD = result.find((n) => n.id === "d");

      // A in column 0, B and C in column 1, D in column 2
      expect(nodeA?.x).toBe(50);
      expect(nodeB?.x).toBe(350);
      expect(nodeC?.x).toBe(350);
      expect(nodeD?.x).toBe(650);
    });
  });

  describe("cycle detection", () => {
    test("handles simple cycle (A → B → A) without infinite loop", () => {
      const nodes: FlowNode[] = [
        {
          id: "a",
          component: "node-a", type: "processor",
          name: "A",
          position: { x: 0, y: 0 },
          config: {},
        },
        {
          id: "b",
          component: "node-b", type: "processor",
          name: "B",
          position: { x: 0, y: 0 },
          config: {},
        },
      ];
      const connections: FlowConnection[] = [
        {
          id: "conn-1",
          source_node_id: "a",
          source_port: "out",
          target_node_id: "b",
          target_port: "in",
        },
        {
          id: "conn-2",
          source_node_id: "b",
          source_port: "out",
          target_node_id: "a",
          target_port: "in",
        },
      ];

      // Should not throw or hang
      const result = layoutNodes(nodes, connections);

      expect(result).toHaveLength(2);
      // Both nodes should be positioned (assigned to column 0 when cycle detected)
      expect(result[0].x).toBeGreaterThanOrEqual(0);
      expect(result[1].x).toBeGreaterThanOrEqual(0);
    });

    test("handles complex cycle in larger graph", () => {
      const nodes: FlowNode[] = [
        {
          id: "a",
          component: "input", type: "input",
          name: "A",
          position: { x: 0, y: 0 },
          config: {},
        },
        {
          id: "b",
          component: "mid", type: "processor",
          name: "B",
          position: { x: 0, y: 0 },
          config: {},
        },
        {
          id: "c",
          component: "mid", type: "processor",
          name: "C",
          position: { x: 0, y: 0 },
          config: {},
        },
        {
          id: "d",
          component: "output", type: "output",
          name: "D",
          position: { x: 0, y: 0 },
          config: {},
        },
      ];
      const connections: FlowConnection[] = [
        {
          id: "1",
          source_node_id: "a",
          source_port: "out",
          target_node_id: "b",
          target_port: "in",
        },
        {
          id: "2",
          source_node_id: "b",
          source_port: "out",
          target_node_id: "c",
          target_port: "in",
        },
        {
          id: "3",
          source_node_id: "c",
          source_port: "out",
          target_node_id: "d",
          target_port: "in",
        },
        {
          id: "4",
          source_node_id: "c",
          source_port: "out",
          target_node_id: "b",
          target_port: "in",
        }, // Cycle: C → B
      ];

      const result = layoutNodes(nodes, connections);

      expect(result).toHaveLength(4);
      // Should complete without hanging
    });
  });

  describe("custom configuration", () => {
    test("respects custom node dimensions", () => {
      const nodes: FlowNode[] = [
        {
          id: "node-1",
          component: "test", type: "processor",
          name: "Test",
          position: { x: 0, y: 0 },
          config: {},
        },
      ];
      const connections: FlowConnection[] = [];
      const config: Partial<LayoutConfig> = {
        nodeWidth: 300,
        nodeHeight: 100,
      };

      const result = layoutNodes(nodes, connections, config);

      expect(result[0].width).toBe(300);
      expect(result[0].height).toBe(100);
    });

    test("respects custom spacing configuration", () => {
      const nodes: FlowNode[] = [
        {
          id: "a",
          component: "input", type: "input",
          name: "A",
          position: { x: 0, y: 0 },
          config: {},
        },
        {
          id: "b",
          component: "output", type: "output",
          name: "B",
          position: { x: 0, y: 0 },
          config: {},
        },
      ];
      const connections: FlowConnection[] = [
        {
          id: "conn-1",
          source_node_id: "a",
          source_port: "out",
          target_node_id: "b",
          target_port: "in",
        },
      ];
      const config: Partial<LayoutConfig> = {
        horizontalSpacing: 200,
        padding: 100,
      };

      const result = layoutNodes(nodes, connections, config);

      const nodeA = result.find((n) => n.id === "a");
      const nodeB = result.find((n) => n.id === "b");

      expect(nodeA?.x).toBe(100); // Custom padding
      expect(nodeB?.x).toBe(100 + 200 + 200); // padding + nodeWidth + horizontalSpacing
    });

    test("respects custom vertical spacing for stacked nodes", () => {
      const nodes: FlowNode[] = [
        {
          id: "a",
          component: "input", type: "input",
          name: "A",
          position: { x: 0, y: 0 },
          config: {},
        },
        {
          id: "b",
          component: "out-1", type: "output",
          name: "B",
          position: { x: 0, y: 0 },
          config: {},
        },
        {
          id: "c",
          component: "out-2", type: "output",
          name: "C",
          position: { x: 0, y: 0 },
          config: {},
        },
      ];
      const connections: FlowConnection[] = [
        {
          id: "1",
          source_node_id: "a",
          source_port: "out",
          target_node_id: "b",
          target_port: "in",
        },
        {
          id: "2",
          source_node_id: "a",
          source_port: "out",
          target_node_id: "c",
          target_port: "in",
        },
      ];
      const config: Partial<LayoutConfig> = {
        verticalSpacing: 100,
        nodeHeight: 80,
      };

      const result = layoutNodes(nodes, connections, config);

      const nodeB = result.find((n) => n.id === "b");
      const nodeC = result.find((n) => n.id === "c");

      const yDifference = Math.abs((nodeB?.y || 0) - (nodeC?.y || 0));
      expect(yDifference).toBe(80 + 100); // nodeHeight + verticalSpacing
    });
  });

  describe("node with no connections", () => {
    test("positions disconnected nodes in column 0", () => {
      const nodes: FlowNode[] = [
        {
          id: "a",
          component: "connected", type: "processor",
          name: "A",
          position: { x: 0, y: 0 },
          config: {},
        },
        {
          id: "b",
          component: "connected", type: "processor",
          name: "B",
          position: { x: 0, y: 0 },
          config: {},
        },
        {
          id: "orphan",
          component: "disconnected", type: "processor",
          name: "Orphan",
          position: { x: 0, y: 0 },
          config: {},
        },
      ];
      const connections: FlowConnection[] = [
        {
          id: "conn-1",
          source_node_id: "a",
          source_port: "out",
          target_node_id: "b",
          target_port: "in",
        },
      ];

      const result = layoutNodes(nodes, connections);

      const orphan = result.find((n) => n.id === "orphan");
      expect(orphan?.x).toBe(50); // Column 0
    });
  });
});

describe("layoutEdges", () => {
  describe("basic edge positioning", () => {
    test("returns empty array when no connections", () => {
      const connections: FlowConnection[] = [];
      const layoutNodes: LayoutNode[] = [];

      const result = layoutEdges(connections, layoutNodes);

      expect(result).toEqual([]);
    });

    test("calculates edge positions from node positions", () => {
      const layoutNodes: LayoutNode[] = [
        {
          id: "a",
          component: "input", type: "input",
          name: "A",
          x: 50,
          y: 50,
          width: 200,
          height: 80,
          config: {},
          original: {
            id: "a",
            component: "input", type: "input",
            name: "A",
            position: { x: 0, y: 0 },
            config: {},
          },
        },
        {
          id: "b",
          component: "output", type: "output",
          name: "B",
          x: 350,
          y: 50,
          width: 200,
          height: 80,
          config: {},
          original: {
            id: "b",
            component: "output", type: "output",
            name: "B",
            position: { x: 0, y: 0 },
            config: {},
          },
        },
      ];
      const connections: FlowConnection[] = [
        {
          id: "edge-1",
          source_node_id: "a",
          source_port: "out",
          target_node_id: "b",
          target_port: "in",
        },
      ];

      const result = layoutEdges(connections, layoutNodes);

      expect(result).toHaveLength(1);
      expect(result[0]).toMatchObject({
        id: "edge-1",
        sourceNodeId: "a",
        sourcePort: "out",
        targetNodeId: "b",
        targetPort: "in",
        sourceX: 250, // 50 + 200 (right side of node A)
        sourceY: 90, // 50 + 40 (middle of node A)
        targetX: 350, // left side of node B
        targetY: 90, // 50 + 40 (middle of node B)
      });
      expect(result[0].original).toBe(connections[0]);
    });

    test("filters out edges with missing source node", () => {
      const layoutNodes: LayoutNode[] = [
        {
          id: "b",
          component: "output", type: "output",
          name: "B",
          x: 350,
          y: 50,
          width: 200,
          height: 80,
          config: {},
          original: {
            id: "b",
            component: "output", type: "output",
            name: "B",
            position: { x: 0, y: 0 },
            config: {},
          },
        },
      ];
      const connections: FlowConnection[] = [
        {
          id: "edge-1",
          source_node_id: "missing",
          source_port: "out",
          target_node_id: "b",
          target_port: "in",
        },
      ];

      const result = layoutEdges(connections, layoutNodes);

      expect(result).toEqual([]);
    });

    test("filters out edges with missing target node", () => {
      const layoutNodes: LayoutNode[] = [
        {
          id: "a",
          component: "input", type: "input",
          name: "A",
          x: 50,
          y: 50,
          width: 200,
          height: 80,
          config: {},
          original: {
            id: "a",
            component: "input", type: "input",
            name: "A",
            position: { x: 0, y: 0 },
            config: {},
          },
        },
      ];
      const connections: FlowConnection[] = [
        {
          id: "edge-1",
          source_node_id: "a",
          source_port: "out",
          target_node_id: "missing",
          target_port: "in",
        },
      ];

      const result = layoutEdges(connections, layoutNodes);

      expect(result).toEqual([]);
    });
  });

  describe("multiple edges", () => {
    test("calculates positions for multiple edges", () => {
      const layoutNodes: LayoutNode[] = [
        {
          id: "a",
          component: "input", type: "input",
          name: "A",
          x: 50,
          y: 50,
          width: 200,
          height: 80,
          config: {},
          original: {
            id: "a",
            component: "input", type: "input",
            name: "A",
            position: { x: 0, y: 0 },
            config: {},
          },
        },
        {
          id: "b",
          component: "mid", type: "processor",
          name: "B",
          x: 350,
          y: 50,
          width: 200,
          height: 80,
          config: {},
          original: {
            id: "b",
            component: "mid", type: "processor",
            name: "B",
            position: { x: 0, y: 0 },
            config: {},
          },
        },
        {
          id: "c",
          component: "output", type: "output",
          name: "C",
          x: 650,
          y: 50,
          width: 200,
          height: 80,
          config: {},
          original: {
            id: "c",
            component: "output", type: "output",
            name: "C",
            position: { x: 0, y: 0 },
            config: {},
          },
        },
      ];
      const connections: FlowConnection[] = [
        {
          id: "edge-1",
          source_node_id: "a",
          source_port: "out",
          target_node_id: "b",
          target_port: "in",
        },
        {
          id: "edge-2",
          source_node_id: "b",
          source_port: "out",
          target_node_id: "c",
          target_port: "in",
        },
      ];

      const result = layoutEdges(connections, layoutNodes);

      expect(result).toHaveLength(2);
      expect(result[0].id).toBe("edge-1");
      expect(result[1].id).toBe("edge-2");
    });
  });

  describe("edge positioning with different node sizes", () => {
    test("calculates correct port positions for tall nodes", () => {
      const layoutNodes: LayoutNode[] = [
        {
          id: "a",
          component: "input", type: "input",
          name: "A",
          x: 50,
          y: 50,
          width: 200,
          height: 200, // Tall node
          config: {},
          original: {
            id: "a",
            component: "input", type: "input",
            name: "A",
            position: { x: 0, y: 0 },
            config: {},
          },
        },
        {
          id: "b",
          component: "output", type: "output",
          name: "B",
          x: 350,
          y: 50,
          width: 200,
          height: 80,
          config: {},
          original: {
            id: "b",
            component: "output", type: "output",
            name: "B",
            position: { x: 0, y: 0 },
            config: {},
          },
        },
      ];
      const connections: FlowConnection[] = [
        {
          id: "edge-1",
          source_node_id: "a",
          source_port: "out",
          target_node_id: "b",
          target_port: "in",
        },
      ];

      const result = layoutEdges(connections, layoutNodes);

      expect(result[0].sourceY).toBe(150); // 50 + 100 (middle of 200 height)
      expect(result[0].targetY).toBe(90); // 50 + 40 (middle of 80 height)
    });
  });
});

describe("calculateCanvasBounds", () => {
  test("returns default dimensions for empty node list", () => {
    const layoutNodes: LayoutNode[] = [];

    const result = calculateCanvasBounds(layoutNodes);

    expect(result).toEqual({ width: 800, height: 600 });
  });

  test("calculates bounds for single node with padding", () => {
    const layoutNodes: LayoutNode[] = [
      {
        id: "node-1",
        component: "test", type: "processor",
        name: "Test",
        x: 50,
        y: 50,
        width: 200,
        height: 80,
        config: {},
        original: {
          id: "node-1",
          component: "test", type: "processor",
          name: "Test",
          position: { x: 0, y: 0 },
          config: {},
        },
      },
    ];

    const result = calculateCanvasBounds(layoutNodes);

    // Max X: 50 + 200 = 250, + 50 padding = 300
    // Max Y: 50 + 80 = 130, + 50 padding = 180
    expect(result).toEqual({ width: 300, height: 180 });
  });

  test("calculates bounds for multiple nodes", () => {
    const layoutNodes: LayoutNode[] = [
      {
        id: "a",
        component: "input", type: "input",
        name: "A",
        x: 50,
        y: 50,
        width: 200,
        height: 80,
        config: {},
        original: {
          id: "a",
          component: "input", type: "input",
          name: "A",
          position: { x: 0, y: 0 },
          config: {},
        },
      },
      {
        id: "b",
        component: "output", type: "output",
        name: "B",
        x: 350,
        y: 200,
        width: 200,
        height: 80,
        config: {},
        original: {
          id: "b",
          component: "output", type: "output",
          name: "B",
          position: { x: 0, y: 0 },
          config: {},
        },
      },
    ];

    const result = calculateCanvasBounds(layoutNodes);

    // Max X: 350 + 200 = 550, + 50 padding = 600
    // Max Y: 200 + 80 = 280, + 50 padding = 330
    expect(result).toEqual({ width: 600, height: 330 });
  });

  test("respects custom padding", () => {
    const layoutNodes: LayoutNode[] = [
      {
        id: "node-1",
        component: "test", type: "processor",
        name: "Test",
        x: 100,
        y: 100,
        width: 200,
        height: 80,
        config: {},
        original: {
          id: "node-1",
          component: "test", type: "processor",
          name: "Test",
          position: { x: 0, y: 0 },
          config: {},
        },
      },
    ];

    const result = calculateCanvasBounds(layoutNodes, 100);

    // Max X: 100 + 200 = 300, + 100 padding = 400
    // Max Y: 100 + 80 = 180, + 100 padding = 280
    expect(result).toEqual({ width: 400, height: 280 });
  });

  test("handles nodes at negative positions", () => {
    const layoutNodes: LayoutNode[] = [
      {
        id: "node-1",
        component: "test", type: "processor",
        name: "Test",
        x: -50,
        y: -50,
        width: 200,
        height: 80,
        config: {},
        original: {
          id: "node-1",
          component: "test", type: "processor",
          name: "Test",
          position: { x: 0, y: 0 },
          config: {},
        },
      },
    ];

    const result = calculateCanvasBounds(layoutNodes);

    // Max X: -50 + 200 = 150, + 50 padding = 200
    // Max Y: -50 + 80 = 30, + 50 padding = 80
    expect(result).toEqual({ width: 200, height: 80 });
  });
});

describe("createZoomBehavior", () => {
  test("creates zoom behavior with default options", () => {
    const onTransform = vi.fn();

    const zoomBehavior = createZoomBehavior(onTransform);

    expect(zoomBehavior).toBeDefined();
    expect(typeof zoomBehavior.on).toBe("function");
    expect(typeof zoomBehavior.scaleExtent).toBe("function");
  });

  test("creates zoom behavior with custom scale extents", () => {
    const onTransform = vi.fn();
    const options = { minZoom: 0.5, maxZoom: 4 };

    const zoomBehavior = createZoomBehavior(onTransform, options);

    expect(zoomBehavior).toBeDefined();
    // Behavior is configured, actual scale enforcement tested via D3 integration
  });

  test("zoom behavior accepts transform callback", () => {
    const onTransform = vi.fn();

    const zoomBehavior = createZoomBehavior(onTransform);

    expect(zoomBehavior).toBeDefined();
    // onTransform will be called by D3 when zoom events occur
  });
});

describe("fitToContent", () => {
  test("is a function that accepts required parameters", () => {
    expect(typeof fitToContent).toBe("function");
    expect(fitToContent.length).toBe(5); // 5 required parameters (padding has default)
  });

  // Note: Full integration testing of fitToContent requires DOM and D3 setup
  // These would be better tested in component integration tests
  // Here we just verify the function signature exists
});
