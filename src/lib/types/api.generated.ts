/**
 * This file was auto-generated by openapi-typescript.
 * Do not make direct changes to the file.
 */

export interface paths {
    "/config/{name}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Get component configuration
         * @description Returns the current configuration for a specific component
         */
        get: {
            parameters: {
                query?: never;
                header?: never;
                path: {
                    /** @description Component name */
                    name: string;
                };
                cookie?: never;
            };
            requestBody?: never;
            responses: {
                /** @description Component configuration */
                200: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content: {
                        "application/json": Record<string, never>;
                    };
                };
                /** @description Component not found */
                404: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content?: never;
                };
            };
        };
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/deployment/{id}/deploy": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /**
         * Deploy flow
         * @description Deploys a flow to the runtime
         */
        post: {
            parameters: {
                query?: never;
                header?: never;
                path?: never;
                cookie?: never;
            };
            requestBody?: never;
            responses: {
                /** @description Flow deployed */
                200: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content?: never;
                };
                /** @description Validation errors */
                400: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content?: never;
                };
            };
        };
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/deployment/{id}/start": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /**
         * Start flow
         * @description Starts a deployed flow
         */
        post: {
            parameters: {
                query?: never;
                header?: never;
                path?: never;
                cookie?: never;
            };
            requestBody?: never;
            responses: {
                /** @description Flow started */
                200: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content?: never;
                };
            };
        };
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/deployment/{id}/stop": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /**
         * Stop flow
         * @description Stops a running flow
         */
        post: {
            parameters: {
                query?: never;
                header?: never;
                path?: never;
                cookie?: never;
            };
            requestBody?: never;
            responses: {
                /** @description Flow stopped */
                200: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content?: never;
                };
            };
        };
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/entries": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Get recent message entries
         * @description Returns the most recent logged messages from the circular buffer
         */
        get: {
            parameters: {
                query?: {
                    /** @description Maximum number of entries to return (default: 100, max: 10000) */
                    limit?: number;
                    /** @description Filter by NATS subject pattern */
                    subject?: string;
                };
                header?: never;
                path?: never;
                cookie?: never;
            };
            requestBody?: never;
            responses: {
                /** @description List of message entries */
                200: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content: {
                        "application/json": components["schemas"]["MessageLogEntry"][];
                    };
                };
            };
        };
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/flowgraph": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Get component FlowGraph
         * @description Returns the complete FlowGraph with nodes and edges for all managed components
         */
        get: {
            parameters: {
                query?: never;
                header?: never;
                path?: never;
                cookie?: never;
            };
            requestBody?: never;
            responses: {
                /** @description FlowGraph with nodes and edges */
                200: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content: {
                        "application/json": Record<string, never>;
                    };
                };
            };
        };
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/flows": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * List all flows
         * @description Returns a list of all visual flows
         */
        get: {
            parameters: {
                query?: never;
                header?: never;
                path?: never;
                cookie?: never;
            };
            requestBody?: never;
            responses: {
                /** @description List of flows */
                200: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content: {
                        "application/json": Record<string, never>;
                    };
                };
            };
        };
        put?: never;
        /**
         * Create a new flow
         * @description Creates a new visual flow
         */
        post: {
            parameters: {
                query?: never;
                header?: never;
                path?: never;
                cookie?: never;
            };
            requestBody?: never;
            responses: {
                /** @description Flow created */
                201: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content: {
                        "application/json": Record<string, never>;
                    };
                };
                /** @description Invalid request */
                400: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content?: never;
                };
            };
        };
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/flows/{id}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Get flow by ID
         * @description Returns a single flow by ID
         */
        get: {
            parameters: {
                query?: never;
                header?: never;
                path: {
                    /** @description Flow ID */
                    id: string;
                };
                cookie?: never;
            };
            requestBody?: never;
            responses: {
                /** @description Flow details */
                200: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content: {
                        "application/json": Record<string, never>;
                    };
                };
                /** @description Flow not found */
                404: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content?: never;
                };
            };
        };
        /**
         * Update flow
         * @description Updates an existing flow
         */
        put: {
            parameters: {
                query?: never;
                header?: never;
                path?: never;
                cookie?: never;
            };
            requestBody?: never;
            responses: {
                /** @description Flow updated */
                200: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content: {
                        "application/json": Record<string, never>;
                    };
                };
                /** @description Flow not found */
                404: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content?: never;
                };
                /** @description Version conflict */
                409: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content?: never;
                };
            };
        };
        post?: never;
        /**
         * Delete flow
         * @description Deletes a flow
         */
        delete: {
            parameters: {
                query?: never;
                header?: never;
                path?: never;
                cookie?: never;
            };
            requestBody?: never;
            responses: {
                /** @description Flow deleted */
                204: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content?: never;
                };
                /** @description Flow not found */
                404: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content?: never;
                };
            };
        };
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/flows/{id}/runtime/health": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Get runtime health
         * @description Returns health status and timing for flow components (status, uptime, last activity)
         */
        get: {
            parameters: {
                query?: never;
                header?: never;
                path: {
                    /** @description Flow ID */
                    id: string;
                };
                cookie?: never;
            };
            requestBody?: never;
            responses: {
                /** @description Runtime health status */
                200: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content: {
                        "application/json": components["schemas"]["RuntimeHealthResponse"];
                    };
                };
                /** @description Flow not found */
                404: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content?: never;
                };
            };
        };
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/flows/{id}/runtime/messages": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Get runtime messages
         * @description Returns filtered message logger entries for flow components (NATS message flow visibility)
         */
        get: {
            parameters: {
                query?: {
                    /** @description Maximum number of messages to return (default: 100, max: 1000) */
                    limit?: number;
                };
                header?: never;
                path: {
                    /** @description Flow ID */
                    id: string;
                };
                cookie?: never;
            };
            requestBody?: never;
            responses: {
                /** @description Runtime message entries */
                200: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content: {
                        "application/json": components["schemas"]["RuntimeMessagesResponse"];
                    };
                };
                /** @description Flow not found */
                404: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content?: never;
                };
            };
        };
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/flows/{id}/runtime/metrics": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Get runtime metrics
         * @description Returns runtime metrics for flow components (throughput, errors, queue depth) with graceful degradation
         */
        get: {
            parameters: {
                query?: never;
                header?: never;
                path: {
                    /** @description Flow ID */
                    id: string;
                };
                cookie?: never;
            };
            requestBody?: never;
            responses: {
                /** @description Runtime metrics */
                200: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content: {
                        "application/json": components["schemas"]["RuntimeMetricsResponse"];
                    };
                };
                /** @description Flow not found */
                404: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content?: never;
                };
            };
        };
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/gaps": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Get component flow gaps
         * @description Returns disconnected nodes and orphaned ports in the component flow
         */
        get: {
            parameters: {
                query?: never;
                header?: never;
                path?: never;
                cookie?: never;
            };
            requestBody?: never;
            responses: {
                /** @description Component flow gaps and disconnected nodes */
                200: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content: {
                        "application/json": Record<string, never>;
                    };
                };
            };
        };
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/graphql": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /**
         * Execute GraphQL query
         * @description Execute GraphQL queries against the knowledge graph. The GraphQL schema is available via introspection query.
         */
        post: {
            parameters: {
                query?: never;
                header?: never;
                path?: never;
                cookie?: never;
            };
            requestBody?: never;
            responses: {
                /** @description GraphQL response with data or errors */
                200: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content: {
                        "application/json": Record<string, never>;
                    };
                };
                /** @description Invalid GraphQL query */
                400: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content?: never;
                };
                /** @description Method not allowed (only POST supported) */
                405: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content?: never;
                };
                /** @description Query timeout */
                504: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content?: never;
                };
            };
        };
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/health": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Get component health status
         * @description Returns aggregated health status for all managed components
         */
        get: {
            parameters: {
                query?: never;
                header?: never;
                path?: never;
                cookie?: never;
            };
            requestBody?: never;
            responses: {
                /** @description Component health information */
                200: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content: {
                        "application/json": Record<string, never>;
                    };
                };
            };
        };
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/inference/anomalies/{id}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Get anomaly by ID
         * @description Returns details of a specific structural anomaly
         */
        get: {
            parameters: {
                query?: never;
                header?: never;
                path: {
                    /** @description Anomaly ID */
                    id: string;
                };
                cookie?: never;
            };
            requestBody?: never;
            responses: {
                /** @description Anomaly details */
                200: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content: {
                        "application/json": components["schemas"]["StructuralAnomaly"];
                    };
                };
                /** @description Anomaly not found */
                404: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content?: never;
                };
                /** @description Internal server error */
                500: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content?: never;
                };
            };
        };
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/inference/anomalies/{id}/review": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /**
         * Submit review decision
         * @description Submit a human review decision (approve or reject) for a structural anomaly
         */
        post: {
            parameters: {
                query?: never;
                header?: never;
                path: {
                    /** @description Anomaly ID */
                    id: string;
                };
                cookie?: never;
            };
            requestBody?: never;
            responses: {
                /** @description Updated anomaly after review */
                200: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content: {
                        "application/json": components["schemas"]["StructuralAnomaly"];
                    };
                };
                /** @description Invalid request (bad decision or missing target entity) */
                400: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content?: never;
                };
                /** @description Anomaly not found */
                404: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content?: never;
                };
                /** @description Anomaly not in reviewable state */
                409: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content?: never;
                };
                /** @description Internal server error */
                500: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content?: never;
                };
            };
        };
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/inference/anomalies/pending": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * List pending anomalies
         * @description Returns structural anomalies awaiting human review
         */
        get: {
            parameters: {
                query?: never;
                header?: never;
                path?: never;
                cookie?: never;
            };
            requestBody?: never;
            responses: {
                /** @description List of pending anomalies */
                200: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content: {
                        "application/json": components["schemas"]["StructuralAnomaly"][];
                    };
                };
                /** @description Internal server error */
                500: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content?: never;
                };
            };
        };
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/inference/stats": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Get inference statistics
         * @description Returns statistics about detected anomalies and their review status
         */
        get: {
            parameters: {
                query?: never;
                header?: never;
                path?: never;
                cookie?: never;
            };
            requestBody?: never;
            responses: {
                /** @description Inference statistics */
                200: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content: {
                        "application/json": components["schemas"]["StatsResponse"];
                    };
                };
                /** @description Internal server error */
                500: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content?: never;
                };
            };
        };
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/kv/{bucket}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Query KV bucket
         * @description Query NATS KV bucket entries (development/test only)
         */
        get: {
            parameters: {
                query?: {
                    /** @description Key pattern to match (e.g., 'entity.*') */
                    pattern?: string;
                    /** @description Maximum number of entries to return (default: 100, max: 1000) */
                    limit?: number;
                };
                header?: never;
                path: {
                    /** @description KV bucket name */
                    bucket: string;
                };
                cookie?: never;
            };
            requestBody?: never;
            responses: {
                /** @description KV bucket entries */
                200: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content: {
                        "application/json": Record<string, never>;
                    };
                };
                /** @description KV query disabled in production */
                403: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content?: never;
                };
                /** @description Bucket not found */
                404: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content?: never;
                };
            };
        };
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/kv/{bucket}/watch": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Watch KV bucket changes
         * @description Stream KV bucket changes via Server-Sent Events (SSE). Supports pattern filtering and SSE reconnection with event IDs.
         */
        get: {
            parameters: {
                query?: {
                    /** @description Key pattern to watch (e.g., 'entity.*'). Default: '*' (all keys) */
                    pattern?: string;
                };
                header?: never;
                path: {
                    /** @description KV bucket name (e.g., ENTITY_STATES, CONTEXT_INDEX) */
                    bucket: string;
                };
                cookie?: never;
            };
            requestBody?: never;
            responses: {
                /** @description SSE stream of KV changes. Events: 'connected' (initial), 'kv_change' (updates), 'error' (failures) */
                200: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content?: never;
                };
                /** @description Invalid bucket name or pattern */
                400: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content?: never;
                };
                /** @description Bucket not found */
                404: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content?: never;
                };
            };
        };
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/list": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * List all components
         * @description Returns a list of all managed components with basic information
         */
        get: {
            parameters: {
                query?: never;
                header?: never;
                path?: never;
                cookie?: never;
            };
            requestBody?: never;
            responses: {
                /** @description List of components */
                200: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content: {
                        "application/json": Record<string, never>;
                    };
                };
            };
        };
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/mcp": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /**
         * MCP endpoint
         * @description Model Context Protocol endpoint for AI tool integration. Enables LLMs to interact with the knowledge graph.
         */
        post: {
            parameters: {
                query?: never;
                header?: never;
                path?: never;
                cookie?: never;
            };
            requestBody?: never;
            responses: {
                /** @description MCP response */
                200: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content: {
                        "application/json": Record<string, never>;
                    };
                };
            };
        };
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/paths": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Get component data paths
         * @description Returns data paths from input components to all reachable components
         */
        get: {
            parameters: {
                query?: never;
                header?: never;
                path?: never;
                cookie?: never;
            };
            requestBody?: never;
            responses: {
                /** @description Data paths through component graph */
                200: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content: {
                        "application/json": Record<string, never>;
                    };
                };
            };
        };
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/stats": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Get message statistics
         * @description Returns statistics about processed messages
         */
        get: {
            parameters: {
                query?: never;
                header?: never;
                path?: never;
                cookie?: never;
            };
            requestBody?: never;
            responses: {
                /** @description Message statistics */
                200: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content: {
                        "application/json": Record<string, never>;
                    };
                };
            };
        };
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/status/{name}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Get component status
         * @description Returns detailed status for a specific component
         */
        get: {
            parameters: {
                query?: never;
                header?: never;
                path: {
                    /** @description Component name */
                    name: string;
                };
                cookie?: never;
            };
            requestBody?: never;
            responses: {
                /** @description Component status */
                200: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content: {
                        "application/json": Record<string, never>;
                    };
                };
                /** @description Component not found */
                404: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content?: never;
                };
            };
        };
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/status/stream": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * WebSocket status stream
         * @description Real-time flow status updates via WebSocket.
         *
         *     ## Connection
         *     Connect with: ws://host/flowbuilder/status/stream?flowId={flowId}
         *
         *     ## Message Types (Server → Client)
         *     All messages are wrapped in StatusStreamEnvelope:
         *     - **flow_status**: Flow state changes (deployed, running, stopped, failed)
         *     - **component_health**: Component health updates (every 5s)
         *     - **component_metrics**: Real-time metrics from MetricsForwarder
         *     - **log_entry**: Log messages from LogForwarder
         *
         *     ## Filtering (Client → Server)
         *     Send SubscribeCommand JSON to filter messages:
         *     - message_types: Array of message types to receive
         *     - log_level: Minimum log level (DEBUG < INFO < WARN < ERROR)
         *     - sources: Array of component names to filter by
         *
         *     ## Example Subscribe Command
         *     {"command":"subscribe","message_types":["flow_status","log_entry"],"log_level":"WARN"}
         */
        get: {
            parameters: {
                query: {
                    /** @description Flow ID to subscribe to for status updates */
                    flowId: string;
                };
                header?: never;
                path?: never;
                cookie?: never;
            };
            requestBody?: never;
            responses: {
                /** @description Switching to WebSocket protocol */
                101: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content?: never;
                };
                /** @description Missing or invalid flowId parameter */
                400: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content?: never;
                };
                /** @description Flow not found */
                404: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content?: never;
                };
            };
        };
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/subjects": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Get monitored subjects
         * @description Returns list of NATS subjects being monitored
         */
        get: {
            parameters: {
                query?: never;
                header?: never;
                path?: never;
                cookie?: never;
            };
            requestBody?: never;
            responses: {
                /** @description List of monitored subjects */
                200: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content: {
                        "application/json": Record<string, never>;
                    };
                };
            };
        };
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/types": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * List available component types
         * @description Returns array of component metadata including schemas
         */
        get: {
            parameters: {
                query?: never;
                header?: never;
                path?: never;
                cookie?: never;
            };
            requestBody?: never;
            responses: {
                /** @description Array of component types */
                200: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content: {
                        "application/json": Record<string, never>;
                    };
                };
            };
        };
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/types/{id}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Get component type by ID
         * @description Returns metadata and schema for a specific component type
         */
        get: {
            parameters: {
                query?: never;
                header?: never;
                path: {
                    /** @description Component type ID */
                    id: string;
                };
                cookie?: never;
            };
            requestBody?: never;
            responses: {
                /** @description Component type metadata */
                200: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content: {
                        "application/json": Record<string, never>;
                    };
                };
                /** @description Component type not found */
                404: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content?: never;
                };
            };
        };
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/validate": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Validate component flow connectivity
         * @description Performs FlowGraph connectivity analysis for operational validation (used by E2E tests)
         */
        get: {
            parameters: {
                query?: never;
                header?: never;
                path?: never;
                cookie?: never;
            };
            requestBody?: never;
            responses: {
                /** @description Flow connectivity analysis results */
                200: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content: {
                        "application/json": Record<string, never>;
                    };
                };
            };
        };
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
}
export type webhooks = Record<string, never>;
export interface components {
    schemas: {
        ComponentType: {
            /** @description Component category */
            category?: string;
            /** @description Component description */
            description?: string;
            /** @description Business domain (robotics, semantic, etc.) */
            domain?: string;
            /** @description Component ID */
            id: string;
            /** @description Human-readable name */
            name: string;
            /** @description Technical protocol (udp, tcp, etc.) */
            protocol?: string;
            /** @description Component configuration schema */
            schema?: components["schemas"]["document_processor.v1"] | components["schemas"]["file.v1"] | components["schemas"]["file_input.v1"] | components["schemas"]["graph-clustering.v1"] | components["schemas"]["graph-embedding.v1"] | components["schemas"]["graph-gateway.v1"] | components["schemas"]["graph-index-spatial.v1"] | components["schemas"]["graph-index-temporal.v1"] | components["schemas"]["graph-index.v1"] | components["schemas"]["graph-ingest.v1"] | components["schemas"]["graph-query.v1"] | components["schemas"]["http.v1"] | components["schemas"]["httppost.v1"] | components["schemas"]["iot_sensor.v1"] | components["schemas"]["json_filter.v1"] | components["schemas"]["json_generic.v1"] | components["schemas"]["json_map.v1"] | components["schemas"]["objectstore.v1"] | components["schemas"]["rule-processor.v1"] | components["schemas"]["udp.v1"] | components["schemas"]["websocket.v1"] | components["schemas"]["websocket_input.v1"];
            /** @description Component type (input/processor/output/storage) */
            type: string;
            /** @description Component version */
            version?: string;
        };
        Flow: {
            connections: {
                id: string;
                source_node_id: string;
                source_port: string;
                target_node_id: string;
                target_port: string;
            }[];
            /** Format: date-time */
            created_at: string;
            created_by?: string;
            /** Format: date-time */
            deployed_at?: string | null;
            description?: string;
            id: string;
            /** Format: date-time */
            last_modified: string;
            name: string;
            nodes: {
                component: string;
                config: {
                    [key: string]: unknown;
                };
                id: string;
                name: string;
                position: {
                    x: number;
                    y: number;
                };
                type: string;
            }[];
            runtime_state: string;
            /** Format: date-time */
            started_at?: string | null;
            /** Format: date-time */
            stopped_at?: string | null;
            /** Format: date-time */
            updated_at: string;
            version: number;
        };
        FlowStatusPayload: {
            error?: string;
            prev_state: string;
            state: string;
            timestamp: number;
        };
        LogEntryPayload: {
            fields: {
                [key: string]: unknown;
            };
            level: string;
            message: string;
            source: string;
        };
        MessageLogEntry: {
            message_id?: string;
            message_type?: string;
            metadata?: {
                [key: string]: unknown;
            };
            /** Format: byte */
            raw_data?: string;
            subject: string;
            summary: string;
            /** Format: date-time */
            timestamp: string;
        };
        MetricEntry: {
            labels: {
                [key: string]: string;
            };
            name: string;
            type: string;
            value: number;
        };
        MetricsPayload: {
            component: string;
            metrics: {
                labels: {
                    [key: string]: string;
                };
                name: string;
                type: string;
                value: number;
            }[];
        };
        RuntimeHealthResponse: {
            components: {
                component: string;
                details: unknown;
                healthy: boolean;
                /** Format: date-time */
                last_activity?: string | null;
                message: string;
                name: string;
                /** Format: date-time */
                start_time?: string | null;
                status: string;
                type: string;
                uptime_seconds?: number | null;
            }[];
            overall: {
                degraded_count: number;
                error_count: number;
                running_count: number;
                status: string;
            };
            /** Format: date-time */
            timestamp: string;
        };
        RuntimeMessagesResponse: {
            limit: number;
            messages: {
                component: string;
                direction: string;
                message_id: string;
                message_type?: string;
                metadata?: {
                    [key: string]: unknown;
                };
                subject: string;
                summary: string;
                timestamp: string;
            }[];
            note?: string;
            timestamp: string;
            total: number;
        };
        RuntimeMetricsResponse: {
            components: {
                component: string;
                error_rate?: number | null;
                name: string;
                queue_depth?: number | null;
                raw_counters?: {
                    [key: string]: number;
                } | null;
                status: string;
                throughput?: number | null;
                type: string;
            }[];
            prometheus_available: boolean;
            /** Format: date-time */
            timestamp: string;
        };
        StatsResponse: {
            applied: number;
            human_approved: number;
            human_rejected: number;
            human_review: number;
            llm_approved: number;
            llm_rejected: number;
            pending_review: number;
            total_detected: number;
        };
        StatusStreamEnvelope: {
            flow_id: string;
            id: string;
            /** Format: byte */
            payload?: string;
            timestamp: number;
            type: string;
        };
        StructuralAnomaly: {
            confidence: number;
            /** Format: date-time */
            detected_at: string;
            entity_a: string;
            entity_a_context?: string;
            entity_b?: string;
            entity_b_context?: string;
            evidence: {
                actual_distance?: number;
                chain_path?: string[];
                community_id?: string;
                core_level?: number;
                current_core_level?: number;
                distance_lower_bound?: number;
                distance_upper_bound?: number;
                expected_max_hops?: number;
                expected_peer_count?: number;
                lost_connections?: number;
                peer_connectivity?: number;
                peer_count?: number;
                predicate?: string;
                previous_core_level?: number;
                similarity?: number;
                structural_distance?: number;
            };
            id: string;
            llm_reasoning?: string;
            review_notes?: string;
            /** Format: date-time */
            reviewed_at?: string | null;
            reviewed_by?: string;
            status: string;
            suggestion?: {
                confidence: number;
                from_entity: string;
                predicate: string;
                reasoning: string;
                to_entity: string;
            } | null;
            type: string;
        };
        SubscribeCommand: {
            command: string;
            log_level?: string;
            message_types?: string[];
            sources?: string[];
        };
        /**
         * document_processor Configuration
         * @description Transforms incoming JSON documents into Graphable payloads for semantic search
         */
        "document_processor.v1": {
            /** @description Port configuration */
            ports?: string;
        };
        /**
         * file Configuration
         * @description File output for writing messages to disk in JSON, JSONL, or raw format
         */
        "file.v1": {
            /** @description Append mode */
            append?: boolean;
            /** @description Buffer size */
            buffer_size?: number;
            /** @description Output directory */
            directory?: string;
            /** @description Prefix */
            file_prefix?: string;
            /**
             * @description format
             * @enum {string}
             */
            format?: "json" | "jsonl" | "raw";
            /** @description Port configuration */
            ports?: string;
        };
        /**
         * file_input Configuration
         * @description File input component for reading JSONL/JSON files and publishing to NATS
         */
        "file_input.v1": {
            /**
             * @description File format (jsonl or json)
             * @default jsonl
             */
            format: string;
            /**
             * @description Delay between lines
             * @default 10ms
             */
            interval: string;
            /** @description Port configuration */
            ports?: string;
        };
        /**
         * graph-clustering Configuration
         * @description Graph community detection and clustering processor
         */
        "graph-clustering.v1": {
            /** @description Configuration for anomaly detection */
            anomaly_config?: Record<string, never>;
            /** @description Event count threshold for triggering detection */
            batch_size?: number;
            /** @description Interval between community detection runs (e.g. 30s or 5m) */
            detection_interval?: string;
            /** @description Enable anomaly detection after structural computation */
            enable_anomaly_detection?: boolean;
            /** @description Enable LLM-based community summarization */
            enable_llm?: boolean;
            /** @description Enable structural index computation (k-core and pivot distance) */
            enable_structural?: boolean;
            /** @description Number of parallel workers for LLM enhancement (default 5) */
            enhancement_workers?: number;
            /** @description URL for LLM endpoint (required if enable_llm is true) */
            llm_endpoint?: string;
            /** @description Model name for LLM service (e.g. mistral-7b-instruct) */
            llm_model?: string;
            /** @description Maximum BFS traversal depth (default 10) */
            max_hop_distance?: number;
            /** @description Maximum iterations for LPA algorithm */
            max_iterations?: number;
            /** @description Minimum number of entities to form a community */
            min_community_size?: number;
            /** @description Number of pivot nodes for distance indexing (default 16) */
            pivot_count?: number;
            /** @description Port configuration */
            ports?: string;
            /** @description Max attempts to wait for dependencies at startup */
            startup_attempts?: number;
            /** @description Interval between startup attempts in milliseconds */
            startup_interval_ms?: number;
        };
        /**
         * graph-embedding Configuration
         * @description Graph entity embedding generation processor
         */
        "graph-embedding.v1": {
            /** @description Batch size for embedding generation */
            batch_size?: number;
            /** @description Cache TTL for embeddings (e.g. 15m or 1h) */
            cache_ttl?: string;
            /** @description Embedder type (bm25 or http) */
            embedder_type?: string;
            /** @description URL for HTTP embedder (required if embedder_type is http) */
            embedder_url?: string;
            /** @description Port configuration */
            ports?: string;
            /** @description Max attempts to wait for dependencies at startup */
            startup_attempts?: number;
            /** @description Interval between startup attempts in milliseconds */
            startup_interval_ms?: number;
        };
        /**
         * graph-gateway Configuration
         * @description Graph operations HTTP gateway
         */
        "graph-gateway.v1": {
            /** @description HTTP server bind address */
            bind_address?: string;
            /** @description Enable inference API for anomaly review */
            enable_inference_api?: boolean;
            /** @description Enable GraphQL playground */
            enable_playground?: boolean;
            /** @description GraphQL endpoint path */
            graphql_path?: string;
            /** @description MCP endpoint path */
            mcp_path?: string;
            /** @description Port configuration */
            ports?: string;
        };
        /**
         * graph-index-spatial Configuration
         * @description Graph spatial indexing processor for geospatial queries
         */
        "graph-index-spatial.v1": {
            /** @description Event batch size */
            batch_size?: number;
            /** @description Geohash precision (1-12) */
            geohash_precision?: number;
            /** @description Port configuration */
            ports?: string;
            /** @description Max attempts to wait for dependencies at startup */
            startup_attempts?: number;
            /** @description Interval between startup attempts in milliseconds */
            startup_interval_ms?: number;
            /** @description Number of worker goroutines */
            workers?: number;
        };
        /**
         * graph-index-temporal Configuration
         * @description Graph temporal indexing processor
         */
        "graph-index-temporal.v1": {
            /** @description Batch size for processing */
            batch_size?: number;
            /** @description Port configuration */
            ports?: string;
            /** @description Max attempts to wait for dependencies at startup */
            startup_attempts?: number;
            /** @description Interval between startup attempts in milliseconds */
            startup_interval_ms?: number;
            /** @description Time resolution (minute hour day) */
            time_resolution?: string;
            /** @description Number of worker goroutines */
            workers?: number;
        };
        /**
         * graph-index Configuration
         * @description Graph relationship index maintenance processor
         */
        "graph-index.v1": {
            /** @description Batch size for index updates */
            batch_size?: number;
            /** @description Port configuration */
            ports?: string;
            /** @description Max attempts to wait for dependencies at startup */
            startup_attempts?: number;
            /** @description Interval between startup attempts in milliseconds */
            startup_interval_ms?: number;
            /** @description Number of worker goroutines */
            workers?: number;
        };
        /**
         * graph-ingest Configuration
         * @description Entity and triple ingestion processor
         */
        "graph-ingest.v1": {
            /** @description Enable hierarchy inference */
            enable_hierarchy?: boolean;
            /** @description Enable sibling edges between same-type entities (default true when hierarchy enabled) */
            enable_type_siblings?: boolean;
            /** @description Port configuration */
            ports?: string;
        };
        /**
         * graph-query Configuration
         * @description Query coordinator for graph subsystem
         */
        "graph-query.v1": {
            /** @description Maximum traversal depth for path search queries */
            max_depth?: string;
            /** @description Port configuration for input and output connections */
            ports: Record<string, never>;
            /** @description Timeout for query operations (e.g., '5s', '10s') */
            query_timeout?: string;
        };
        /**
         * http Configuration
         * @description HTTP gateway for bidirectional NATS request/reply
         */
        "http.v1": {
            /** @description Allowed origins (required for CORS) */
            cors_origins?: string[];
            /** @description Enable CORS */
            enable_cors?: boolean;
            /** @description Max request size (bytes) */
            max_request_size?: number;
            /** @description Route mappings */
            routes?: string[];
        };
        /**
         * httppost Configuration
         * @description HTTP POST output for sending messages to HTTP endpoints with retries
         */
        "httppost.v1": {
            /** @description Content-Type */
            content_type?: string;
            /** @description HTTP headers */
            headers?: Record<string, never>;
            /** @description Port configuration */
            ports?: string;
            /** @description Retry count */
            retry_count?: number;
            /** @description Timeout (sec) */
            timeout?: number;
            /** @description HTTP endpoint URL */
            url?: string;
        };
        /**
         * iot_sensor Configuration
         * @description Transforms incoming JSON sensor data into Graphable SensorReading payloads
         */
        "iot_sensor.v1": {
            /** @description Port configuration */
            ports?: string;
        };
        /**
         * json_filter Configuration
         * @description GenericJSON (core .json.v1) filter for field-based filtering
         */
        "json_filter.v1": {
            /** @description Port configuration */
            ports?: string;
            /** @description Filter rules */
            rules?: string[];
        };
        /**
         * json_generic Configuration
         * @description Wraps plain JSON into GenericJSON (core .json.v1) format
         */
        "json_generic.v1": {
            /** @description Port configuration */
            ports?: string;
        };
        /**
         * json_map Configuration
         * @description GenericJSON (core .json.v1) field transformer for renaming, adding, and removing fields
         */
        "json_map.v1": {
            /** @description Static fields */
            add_fields?: Record<string, never>;
            /** @description Field mappings */
            mappings?: string[];
            /** @description Port configuration */
            ports?: string;
            /** @description Field removal */
            remove_fields?: string[];
        };
        /**
         * objectstore Configuration
         * @description NATS ObjectStore component for immutable message storage
         */
        "objectstore.v1": {
            /**
             * @description NATS ObjectStore bucket name
             * @default MESSAGES
             */
            bucket_name: string;
            /** @description Port configuration for inputs and outputs */
            ports?: string;
        };
        /**
         * rule-processor Configuration
         * @description Rule execution processor
         */
        "rule-processor.v1": {
            /**
             * @description Minimum time between repeated alerts (e.g. '2m')
             * @default 2m
             */
            alert_cooldown_period: string;
            /**
             * @description Time window for message buffering (e.g. '10m')
             * @default 10m
             */
            buffer_window_size: string;
            /**
             * @description Debounce delay in milliseconds for rule evaluation (0=disabled)
             * @default 0
             */
            debounce_delay_ms: number;
            /**
             * @description Enable graph entity creation from rules
             * @default true
             */
            enable_graph_integration: boolean;
            /** @description NATS KV patterns to watch for entity changes (e.g. 'telemetry.robotics.>') */
            entity_watch_patterns?: string[];
            /** @description Inline rule definitions (alternative to files) */
            inline_rules?: string[];
            /** @description Port configuration for inputs (KV watch: ENTITY_STATES PREDICATE_INDEX) and outputs (NATS: control commands) */
            ports?: string;
            /**
             * @description Dynamic rule definitions (rules.{rule_id} pattern)
             * @default {}
             */
            rules: Record<string, never>;
            /**
             * @description Paths to JSON rule definition files
             * @default [
             *       "[]"
             *     ]
             */
            rules_files: string[];
        };
        /**
         * udp Configuration
         * @description UDP input component for receiving MAVLink and other UDP data
         */
        "udp.v1": {
            /** @description Port configuration */
            ports?: string;
        };
        /**
         * websocket Configuration
         * @description WebSocket output component for real-time visualization and data streaming
         */
        "websocket.v1": {
            /** @description Acknowledgment timeout (e.g. 5s) */
            ack_timeout?: string;
            /** @description Delivery reliability mode */
            delivery_mode?: string;
            /** @description Port configuration */
            ports?: string;
        };
        /**
         * websocket_input Configuration
         * @description WebSocket input for receiving federated data from remote StreamKit instances
         */
        "websocket_input.v1": {
            /** @description Backpressure handling configuration */
            backpressure?: Record<string, never>;
            /** @description Bidirectional request/reply configuration */
            bidirectional?: Record<string, never>;
            /** @description Operation mode (server or client) */
            mode?: string;
            /** @description Port configuration */
            ports?: string;
        };
    };
    responses: never;
    parameters: never;
    requestBodies: never;
    headers: never;
    pathItems: never;
}
export type $defs = Record<string, never>;
export type operations = Record<string, never>;
